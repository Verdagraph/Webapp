var dt=Object.defineProperty;var ft=(n,e,t)=>e in n?dt(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var f=(n,e,t)=>ft(n,typeof e!="symbol"?e+"":e,t);import"../chunks/CWj6FrbW.js";import{i as ht}from"../chunks/D4tMsWHK.js";import{p as yt,av as gt,f as pt,a as mt,$ as wt}from"../chunks/C33ZBluP.js";import{h as bt}from"../chunks/BNEUvLy9.js";import{c as St,a as Ct}from"../chunks/VptmxkcR.js";import{i as vt}from"../chunks/QJ-cPXuW.js";import{o as Et}from"../chunks/BKUxGAWh.js";import{a as C,i as me,E as kt,b as K,c as We,h as Tt,I as E,e as S,f as we,g as be,j as Rt,k as O,o as It,l as Pt,m as Ot,n as xt,p as At,q as Ft,r as Se,s as $,t as ue,u as re,v as He,w as $t,x as _t,S as Ce,y as Nt,V as A,z as Dt,A as jt,B as Mt,C as Lt,D as z,F as Q,G as q,H as ve,J as Qt,K as Ue,L as Wt,M as Ht,N as Ut,O as Ve,Q as Vt,U as ee,W as Bt,X as m,Y as zt,Z as Kt,_ as Gt,$ as de,a0 as Jt,a1 as Yt,a2 as Be,a3 as Zt,a4 as Xt,a5 as qt,a6 as en,a7 as tn,a8 as Ee,a9 as ke,aa as te,ab as nn,ac as sn,ad as Te,ae as rn,af as Re,ag as an,ah as on,ai as cn,aj as ln,ak as un,al as Ie,am as dn,an as fn,ao as hn,ap as yn,d as gn,aq as pn,ar as mn,as as wn,at as bn,au as Pe}from"../chunks/CWz9Okes.js";import{g as Sn}from"../chunks/BuzpPzY2.js";import{p as Cn}from"../chunks/VBhAFdqd.js";function ze(n,e){if(!n)return;const t=n[e];if(t)return t.permissions}function vn(n){return n==="read"}function En(n){return!vn(n)}function kn(n,e){if(!n&&!e)return!0;if(!n||!e)return!1;const t=Object.keys(n),i=Object.keys(e);if(t.length!==i.length)return!1;for(const s of t){const r=n[s],a=e[s];if(!Tn(r,a))return!1}return!0}function Tn(n,e){return!n&&!e?!0:!(!n||!e||!j(n.read,e.read)||!j(n.insert,e.insert)||!j(n.update,e.update)||!j(n.postUpdate,e.postUpdate)||!j(n.delete,e.delete))}function j(n,e){return!n&&!e?!0:!(!n||!e||!Rn(n.filter,e.filter))}function Rn(n,e){return!n&&!e?!0:!n||!e?!1:JSON.stringify(n)===JSON.stringify(e)}function In(n,e){if(!n&&!e)return!0;if(!n||!e)return!1;const t=Object.keys(n),i=Object.keys(e);if(t.length!==i.length)return!1;for(const s of t){const r=n[s],a=e[s];if(!Pn(r,a))return!1}return!0}function Pn(n,e){return!n&&!e?!0:!(!n||!e||!On(n.match,e.match))}function On(n,e){if(!n&&!e)return!0;if(!n||!e)return!1;const t=Object.keys(n),i=Object.keys(e);if(t.length!==i.length)return!1;for(const s of t){const r=n[s],a=e[s];if(JSON.stringify(r)!==JSON.stringify(a))return!1}return!0}function xn(n){return n._diff==="collectionAttribute"}function Ke(n,e,t=[]){if(n===void 0&&e===void 0)return[];const i=(n==null?void 0:n.properties)??{},s=(e==null?void 0:e.properties)??{},r=new Set([...Object.keys(i),...Object.keys(s)]),a=[];for(const o of r){if(!(o in i)){const c=[...t,o];a.push({type:"insert",attribute:c,dataType:s[o],isNewCollection:n===void 0});continue}if(!(o in s)){const c=[...t,o];a.push({type:"delete",attribute:c,dataType:i[o]});continue}if(o in i&&o in s){if(C.equal(i[o],s[o]))continue;const c=[...t,o];if(i[o].type==="record"&&s[o].type==="record"){a.push(...Ke(i[o],s[o],c));continue}const l={type:"update",attribute:c,changes:{config:{}}};i[o].type!==s[o].type&&(l.changes.type=s[o].type),i[o].type==="set"&&s[o].type==="set"&&i[o].items.type!==s[o].items.type&&(l.changes.items={type:s[o].items.type}),l.changes.config=An(i[o].config??{},s[o].config??{}),a.push(l);continue}}return a}function An(n,e){var r;const t={};n.nullable!==e.nullable&&(t.nullable=!!e.nullable),n.optional!==e.optional&&(t.optional=!!e.optional),n.default!==e.default&&(t.default=e.default);const i=e.enum&&!n.enum,s=n.enum&&e.enum&&!((r=n.enum)!=null&&r.every(a=>{var o;return(o=e.enum)==null?void 0:o.includes(a)}));return(i||s)&&(t.enum=e.enum),t}function Fn(n,e){const t=new Set([...Object.keys(n.collections),...Object.keys(e.collections)]),i=[];for(const r of t){const a=n.collections[r],o=e.collections[r];i.push(...Ke(a==null?void 0:a.schema,o==null?void 0:o.schema).map(l=>({_diff:"collectionAttribute",collection:r,...l}))),!kn(a==null?void 0:a.permissions,o==null?void 0:o.permissions)&&i.push({_diff:"collectionPermissions",collection:r})}return!In(n.roles,e.roles)&&i.push({_diff:"roles"}),i}function $n(n){return n.reduce((e,t)=>{if(!xn(t))return e;const i=_n.find(s=>s.matchesDiff(t));return i&&e.push({issue:i.description,dataConstraint:i.dataConstraint,context:t,attributeCure:i.attributeCure}),e},[])}const _n=[{description:"removed an optional attribute",matchesDiff:n=>n.type==="delete"&&me(n.dataType),dataConstraint:"attribute_is_empty",attributeCure:()=>null},{description:"removed a required attribute",matchesDiff:n=>n.type==="delete",dataConstraint:"collection_is_empty",attributeCure:(n,e)=>`make '${e.join(".")}' optional`},{description:"changed a attribute from optional to required",matchesDiff:n=>{var e;return n.type==="update"?((e=n.changes.config)==null?void 0:e.optional)===!1:!1},dataConstraint:"attribute_has_no_undefined",attributeCure:()=>null},{description:"changed the type of an attribute",matchesDiff:n=>n.type==="update"?n.changes.type!==void 0:!1,dataConstraint:"attribute_is_empty",attributeCure:(n,e)=>`revert the change to '${e.join(".")}' and create a different, optional, attribute with the new type`},{description:"changed the type of a set's items",matchesDiff:n=>n.type==="update"?n.changes.items!==void 0:!1,dataConstraint:"attribute_is_empty",attributeCure:(n,e)=>`revert the change to '${e.join(".")}' and create a different, optional, attribute with the new type`},{description:"added an attribute where optional is not set",matchesDiff:n=>n.type==="insert"&&!n.isNewCollection&&!me(n.dataType),dataConstraint:"collection_is_empty",attributeCure:(n,e)=>`make '${e.join(".")}' optional`},{description:"changed an attribute from nullable to non-nullable",matchesDiff:n=>{var e;return n.type==="update"?((e=n.changes.config)==null?void 0:e.nullable)===!1:!1},dataConstraint:"attribute_has_no_null",attributeCure:()=>null},{description:"added an enum to an attribute or removed an option from an existing enum",matchesDiff:n=>{var e;return n.type==="update"?((e=n.changes.config)==null?void 0:e.enum)!==void 0:!1},dataConstraint:"attribute_satisfies_enum",attributeCure:(n,e,t)=>`revert the change to '${e.join(".")}' and create a different, optional, attribute with the new enum OR ensure all values of '${e.join(".")} are in the new enum: ${t}`}];async function Nn(n,e,t){var i;return await jn[t](n,e.collection,e.attribute,(e==null?void 0:e.type)==="update"?(i=e.changes.config)==null?void 0:i.enum:void 0)}async function Dn(n,e){const t=$n(e);return await Promise.all(t.map(async s=>{const r=!await Nn(n,s.context,s.dataConstraint),a=s.dataConstraint&&Mn[s.dataConstraint](s.context.collection,s.context.attribute),o=s.attributeCure(s.context.collection,s.context.attribute);return{...s,violatesExistingData:r,cure:o&&a?o+" or "+a:a}}))}const jn={never:async()=>!1,none:async()=>!0,collection_is_empty:Un,attribute_is_empty:Wn,attribute_has_no_undefined:Qn,attribute_has_no_null:Hn,attribute_satisfies_enum:Ln},Mn={never:()=>"This edit is never allowed",none:()=>"This edit does not violate any data constraints but can cause existing queries that reference this attribute to fail",collection_is_empty:n=>`delete all entities in '${n}' to allow this edit`,attribute_is_empty:(n,e)=>`set all values of '${e.join(".")}' to undefined to allow this edit`,attribute_has_no_undefined:(n,e)=>`ensure all values of '${e.join(".")}' are not undefined to allow this edit`,attribute_has_no_null:(n,e)=>`ensure all values of '${e.join(".")}' are not null to allow this edit`,attribute_satisfies_enum:(n,e)=>`ensure all values of '${e.join(".")}' are in the enum to allow this edit`};async function Ln(n,e,t,i){return(await n({collectionName:e,select:["id"],limit:1,where:[[t.join("."),"nin",i]]})).length===0}async function Qn(n,e,t){return(await n({collectionName:e,select:["id"],limit:1,where:[[t.join("."),"isDefined",!1]]})).length===0}async function Wn(n,e,t){return(await n({collectionName:e,select:["id"],limit:1,where:[[t.join("."),"isDefined",!0]]})).length===0}async function Hn(n,e,t){return(await n({collectionName:e,select:["id"],limit:1,where:[[t.join("."),"=",null]]})).length===0}async function Un(n,e){return(await n({collectionName:e,select:["id"],limit:1})).length===0}function Vn(n,{logger:e,forcePrintIssues:t=!1}={}){const i=e??console;if(n.successful?i.info("Schema update successful"):i.error("Schema update failed. Please resolve the following issues:"),n.invalid){i.error(n.invalid);return}const s=`Found ${n.issues.length} backwards incompatible schema changes.`;if(n.issues.length>0?i.warn(s):i.info(s),!n.successful||t){const r=n.issues.filter(a=>t||a.violatesExistingData);Bn(i,r)}}function Bn(n,e){e.reduce((i,s)=>{const r=s.context.collection,a=i.get(r)??[];return i.set(r,[...a,s]),i},new Map).forEach((i,s)=>{n.error(`
Collection: '${s}'`),i.forEach(({issue:r,context:a,cure:o})=>{n.error(`	'${a.attribute.join(".")}'
		Issue: ${r}
		Fix:   ${o}`)})}),n.info("")}class _{constructor(e){f(this,"lastPhysicalTimeMs");f(this,"lastLogicalTime");f(this,"clientId","");this.clientId=e.clientId,this.lastPhysicalTimeMs=e.lastPhysicalTimeMs||0,this.lastLogicalTime=e.lastLogicalTime||0}get currentPhysicalTimeMs(){return Date.now()}current(){return[this.currentPhysicalTimeMs,this.lastLogicalTime,this.clientId]}next(){const e=this.currentPhysicalTimeMs;return e>this.lastPhysicalTimeMs?(this.lastPhysicalTimeMs=e,this.lastLogicalTime=0):this.lastLogicalTime+=1,[this.lastPhysicalTimeMs,this.lastLogicalTime,this.clientId]}updatePhysicalTimeMs(e){this.lastPhysicalTimeMs=e}static compare(e,t){return e[0]===t[0]?e[1]===t[1]?e[2].localeCompare(t[2]):e[1]-t[1]:e[0]-t[0]}}f(_,"MIN",Object.freeze([0,0,""]));class zn{constructor(e=[]){f(this,"storagePrefix");this.storagePrefix=e}async getHighestTimestamp(e){return await e.scope(this.storagePrefix).get(["highestTimestamp"])??_.MIN}async applyChanges(e,t,i){const s=e.scope(this.storagePrefix),r=await this.getHighestTimestamp(e),a=[];for(const[c,l]of Object.entries(t)){const u=[...l.sets.keys(),...l.deletes];for(const d of u){const h={collectionName:c,id:d,delete:l.deletes.has(d),set:l.sets.get(d)};a.push(h)}}if(_.compare(i,r)>0){for(const c of a)await s.set([c.collectionName,c.id],i);return await s.set(["highestTimestamp"],i),t}const o={};for(const c of a){const{collectionName:l,id:u,delete:d,set:h}=c,y=[l,u],g=await s.get(y);(!g||_.compare(i,g)>0)&&(await s.set(y,i),o[l]||(o[l]={sets:new Map,deletes:new Set}),d&&o[l].deletes.add(u),h&&o[l].sets.set(u,h))}return o}async getTimestampForEntity(e,t,i){return e.scope(this.storagePrefix).get([t,i])??null}}class ae{constructor(e=[]){f(this,"storagePrefix");f(this,"metadataStore");f(this,"dataStore");this.storagePrefix=e,this.metadataStore=new zn([...this.storagePrefix,"metadata"]),this.dataStore=new kt([...this.storagePrefix,"data"])}async applyChanges(e,t,i){return this.dataStore.applyChanges(e,t,i)}async applyChangesWithTimestamp(e,t,i,s){const r=await this.metadataStore.applyChanges(e,t,i);return this.dataStore.applyChanges(e,r,s)}async getEntity(e,t,i){return this.dataStore.getEntity(e,t,i)}getEntitiesInCollection(e,t){return this.dataStore.getEntitiesInCollection(e,t)}getCollectionStats(e,t){return this.dataStore.getCollectionStats(e,t)}}function Kn(n,e,t){let i=Gn(n,e,t),s=i.next();for(;!s.done;)s=i.next();return s.value}function Ge(n,e,t,i){let s=G(e,t);const r=n.split(".");let a=[];for(let o=0;o<r.length;o++){const c=r[o];s=s.get(c),a.push(c);const{valid:l,reason:u}=i(s.current,o,r);if(!l)return{valid:l,path:a.join("."),reason:u}}return{valid:!0}}function Gn(n,e,t){let i=G(e,t);const s=n[Symbol.iterator]();return{next(){const{value:r,done:a}=s.next();return a?{done:a,value:i.current}:(i=i.get(r),{done:!1,value:i.current})},[Symbol.iterator](){return this}}}function W(n,e,t){let i=G(e,t),s=[];const r=n[Symbol.iterator]();return{next(){const{value:a,done:o}=r.next();return o?{done:o,value:[s,i.current]}:(i=i.get(a),s.push(a),{done:!1,value:[s,i.current]})},[Symbol.iterator](){return this}}}function G(n,e){var r,a;let t=!0,i=(r=n[e])==null?void 0:r.schema;const s=o=>{if(i===void 0)return{get:s,current:i};if(k(i))return G(n,i.query.collectionName).get(o);let c=i;return t&&o in(n[e].relationships??{})?c=n[e].relationships[o]:i.type==="record"?(c=i.properties[o],t=!1):i.type==="json"?(c=i,t=!1):c=void 0,i=c,{get:s,current:i}};return{get:s,current:(a=n[e])==null?void 0:a.schema}}function k(n){return n!==void 0&&"query"in n}function J(n){return n.where=Jn(n.where),n.include=qn(n.include),n.order=ei(n.order),n}function Jn(n){if(!n)return n;if(n=fe(n,"and"),n.length!==0)return n}function fe(n,e){let t=[];for(let i=0;i<n.length;i++){const s=n[i],r=Je(s);if(r!==void 0)if(K(r)&&r.mod===e)for(const a of r.filters)t.push(a);else t.push(r)}return t=Xn(t,e),Yn(t,e)}function Yn(n,e){const t=new Set,i=[];for(const s of n){const{hash:r}=Tt(s);t.has(r)||(t.add(r),i.push(s))}return i.length!==n.length?fe(i,e):i}function Je(n){return K(n)?Zn(n):We(n)?{exists:J(n.exists)}:n}function Zn(n){if(n.filters=fe(n.filters,n.mod),n.filters.length!==0)return n.filters.length===1?Je(n.filters[0]):n}function Xn(n,e){return e==="and"&&n.some(t=>t===!1)?[!1]:e==="or"&&n.some(t=>t===!0)?[!0]:n}function qn(n){if(!n)return n;const e=Object.keys(n);if(e.length!==0){for(const t of e){const i=n[t];i.subquery=J(i.subquery)}return n}}function ei(n){if(!n)return n;if(n.length!==0){for(let e=0;e<n.length;e++){const t=n[e];if(t.length===3){const i=t[2];n[e]=[t[0],t[1],{...i,subquery:J(i.subquery)}]}}return n}}function Ye(n){return!Y(n)&&typeof n=="object"&&"subquery"in n}function Y(n){return n===!0||n===null}function Ze(n){return!Y(n)&&typeof n=="object"&&"_extends"in n}function ti(n){return n==="one"||n==="many"}const Oe=Object.freeze([!1]);function x(n,e,t,i,s){n.vars&&!t.$query&&(t={...t,$query:n.vars});const r=Z(n,e,t,i,{applyPermission:s.applyPermission,isExpandingPermission:!1,permissionStack:[],queryStack:[],replaceStaticVariables:s.replaceStaticVariables??!0});return J(r)}function Z(n,e,t,i,s){s.queryStack.push(n);const r={collectionName:ii(n,e),select:si(n,e),include:ri(n,e,t,i,s),where:ai(n,e,t,i,s),order:oi(n,e,t,i,s),limit:ci(n),after:li(n,e)};return s.queryStack.pop(),r}function ni(n){return n==="_metadata"}function ii(n,e){const t=n.collectionName;if(!t)throw new $(t,"Collection name must be provided");if(!(typeof t=="string"))throw new $(t,"Collection name must be a string");if(e&&!e[t]&&!ni(t))throw new $(t,`Collection '${t}' does not exist in the schema`);return t}function si(n,e){if(!n.select)return n.select;for(const t of n.select){if(typeof t!="string")throw new Se(`Select field '${t}' is not a string`);if(e){const{valid:i,path:s,reason:r}=Ge(t,e,n.collectionName,(a,o,c)=>a?k(a)?{valid:!1,reason:"Cannot select into relationships, please use 'include' instead"}:{valid:!0}:{valid:!1,reason:"Path not found"});if(!i)throw new Se(`Select field '${t}' is not valid: ${r} at path '${s}'`)}}return[...n.select]}function ri(n,e,t,i,s){if(!n.include)return n.include;const r={};for(let[a,o]of Object.entries(n.include)){if(e){let l,u=null;if(Y(o))l=a;else if(Ze(o)){const{_extends:d,...h}=o;l=d,u=h}if(l){const d=Kn(l.split("."),e,n.collectionName);if(d&&k(d))o={subquery:ui(d.query,u),cardinality:d.cardinality};else throw d?new xt(l,a,n.collectionName):new Ot(l,a,n.collectionName)}}if(!Ye(o))throw new At(o);if(!ti(o.cardinality))throw new Ft(o.cardinality);const c=Z(o.subquery,e,t,i,s);r[a]={subquery:c,cardinality:o.cardinality}}return r}function ai(n,e,t,i,s){var c;let r=n.where??[];if(!Array.isArray(r))throw new Rt(n.where,"Where clause must be an array");r=[...r];const a=oe(r,n,e,t,i,s);if(s.applyPermission&&(!s.isExpandingPermission||!s.permissionStack.includes(n.collectionName))){const l=ze(e,n.collectionName);if(l){let u=[],d=!1;if(i!=null&&i.roles)for(const y of i.roles){const g=(c=l[y.key])==null?void 0:c[s.applyPermission];if(g!=null&&g.filter)if(Array.isArray(g.filter))if(d=!0,g.filter.length===0)u.push(Oe);else{const p={...s,applyPermission:En(s.applyPermission)?"read":s.applyPermission,isExpandingPermission:!0,permissionStack:[...s.permissionStack??[],n.collectionName]},b=Xe(g.filter);u.push(oe(b,n,e,{...t,$role:y.roleVars},i,p))}else throw new O("Invalid permission filter format, expected array")}!d&&s.applyPermission!=="postUpdate"&&(u=[Oe]);const h=It(u.map(y=>Pt(y)));a.push(h)}}if(a.length)return a}function Xe(n){return n.map(e=>{if(ue(e)){const[t,i,s]=e;if(re(s)){const r=He(s);if(r[0]===void 0)return r[0]=0,[t,i,"$"+r.join(".")]}return[t,i,s]}return K(e)?{...e,filters:Xe(e.filters)}:e})}function oe(n,e,t,i,s,r){return n.map(a=>B(a,e,t,i,s,r))}function B(n,e,t,i,s,r){if($t(n))return n;if(K(n)){if(n.mod!=="and"&&n.mod!=="or")throw new O(`Invalid filter group mod '${n.mod}'`);return{mod:n.mod,filters:oe(n.filters,e,t,i,s,r)}}if(ue(n)){let[a,o,c]=n;if(t){const l=a.split(".");let u;for(const[d,h]of W(l,t,e.collectionName)){if(k(h)){const y={...h.query},g=l.slice(d.length).join(".");return re(c)&&(c=_t(c)),y.where=[...y.where??[],[g,o,c]],B({exists:y},y,t,i,s,r)}u=h}if(!u)throw new O(`Could not find property '${a}' in the schema`);if(u.type==="set"&&!o.startsWith(Ce)&&(o=`${Ce}${o}`),!C.supportedOperations(u).includes(o))throw new O(`Operator '${o}' is not valid for property '${a}' of type '${u.type}'`)}if(re(c)){const l=He(c);let u=l[0];if(u===void 0&&(l[0]=1,u=l[0],c="$"+l.join(".")),Nt(u)){if(t){const d=r.queryStack[r.queryStack.length-u-1],h=l.slice(1);for(const[y,g]of W(h,t,d.collectionName))if(k(g)){const p={...g.query},b=Dt(p,r.queryStack.length-1),T=h.slice(y.length).join("."),P=jt(o);let U=`$1.${a}`;return b.where=[...b.where??[],[T,P,U]],B({exists:b},p,t,i,s,r)}}}else if(r.replaceStaticVariables){const d=A.Get(i,l);if(d===void 0)return!1;c=d}}return c instanceof Date&&(c=c.toISOString()),Array.isArray(c)&&(c=new Set(c)),[a,o,c]}if(Mt(n)){if(!t)throw new O("A schema is required to execute an exists filter");const{exists:a}=n,{_extends:o,...c}=a,l=o.split(".");let u,d;for(const[p,b]of W(l,t,e.collectionName))if(u=p,d=b,k(d))break;if(!d)throw new O(`Could not find property '${o}' in the schema`);if(!k(d))throw new O("Cannot execute an exists filter on a non-relation property");const h={...d.query},g=l.length===u.length?c==null?void 0:c.where:[Lt(l.slice(u.length).join("."),c)];return h.where=[...d.query.where??[],...g??[]],B({exists:h},h,t,i,s,r)}if(We(n)){const{exists:a}=n,o={collectionName:a.collectionName,where:a.where};return{exists:Z(o,t,i,s,r)}}throw new O("Filter is not valid format")}function oi(n,e,t,i,s){if(!n.order)return n.order;const r=[];for(const[a,o]of n.order){if(o!=="ASC"&&o!=="DESC")throw new be(`Invalid order direction '${o}'`);if(e){const{valid:c,path:l,reason:u}=Ge(a,e,n.collectionName,(h,y,g)=>h?y===g.length-1&&(k(h)||h.type==="set"||h.type==="record")?{valid:!1,reason:"Order by field is not sortable"}:k(h)&&h.cardinality!=="one"?{valid:!1,reason:"Order by field is a query with cardinality not equal to one"}:{valid:!0}:{valid:!1,reason:"Path not found"});if(!c)throw new be(`Order by field '${a}' is not valid: ${u} at path '${l}'`);let d;for(const[h,y]of W(a.split("."),e,n.collectionName)){const g=h[h.length-1];if(y&&k(y)){const p={...y.query};d?d.include={...d.include,[g]:{subquery:p,cardinality:y.cardinality}}:(d=p,y.cardinality)}else break}if(d){const h=Z(d,e,t,i,s);r.push([a,o,{subquery:h,cardinality:"one"}]);continue}}r.push([a,o])}return r}function ci(n){if(!n.limit)return n.limit;if(typeof n.limit!="number")throw new we("Limit must be a number");if(n.limit<0)throw new we("Limit must be a positive number");return n.limit}function li(n,e){if(!n.after)return n.after;if(!Array.isArray(n.after))throw new E("After clause must be an array");if(n.after.length<2)throw new E("After clause must contain a cursor and inclusive flag");if(n.after.length>2)throw new E("After clause has too many components - it should contain a cursor and inclusive flag");if(!Array.isArray(n.after[0]))throw new E("After clause cursor must be an array");if(!n.order)throw new E("After clause requires an order by clause to be provided");if(n.after[0].length!==n.order.length)throw new E("After clause cursor must match the elements in the order by clause");if(typeof n.after[1]!="boolean")throw new E("After clause inclusive flag must be a boolean");const t=[];for(let i=0;i<n.order.length;i++){let s=n.after[0][i];if(s===void 0)throw new E("Cursor value cannot be undefined");if(e){const r=n.order[i][0].split(".");for(const[a,o]of W(r,e,n.collectionName)){if(!o)throw new E(`Attribute ${n.order[i][0]} not found in schema`);if(k(o))throw new E(`Attribute ${n.order[i][0]} is not allowed in after clause because it is relational`);if(a.length===r.length){if(o.type==="set"||k(o)||o.type==="record")throw new E(`Attribute ${n.order[i][0]} is not allowed in after clause because the type is not sortable`);try{s=C.encode(o,s)}catch(l){throw l instanceof S?new E(`Error converting cursor value for attribute ${n.order[i][0]}: ${l.message}`):l}}}}s instanceof Date&&(s=s.toISOString()),t.push(s)}return[t,n.after[1]]}function ui(n,e){if(!e)return{...n};const t=n.where||e.where?[...n.where??[],...e.where??[]]:void 0,i=n.select||e.select?[...n.select??[],...e.select??[]]:void 0;return{...n,...e,where:t,select:i}}function he(n,e,t){return!t&&!e?n:n?e?t:z({},n,t):t}async function*qe(n,e){if(!e){yield*n;return}const t=new Set;for await(const i of n){const s=i.id;t.add(s);const r=he(i,e.deletes.has(s),e.sets.get(s));r&&(yield r)}for(const[i,s]of e.sets)!t.has(i)&&!e.deletes.has(i)&&(yield s)}class di{constructor(e){f(this,"kvTx");f(this,"entityStore");f(this,"changes",{});f(this,"schema");f(this,"systemVars");f(this,"session");f(this,"typeConverters");f(this,"skipRules");this.kvTx=e.kvTx,this.entityStore=new fi(e.entityStore,this.changes),this.schema=e.schema,this.systemVars=e.systemVars,this.session=e.session,this.typeConverters=e.typeConverters,this.skipRules=e.skipRules}async fetch(e){var r;const t=x(e,(r=this.schema)==null?void 0:r.collections,this.systemVars,this.session,{applyPermission:this.skipRules?void 0:"read"});let s=await new Q(this.kvTx,this.entityStore).fetch(t);return H(s,t,"many",this.typeConverters)}async fetchOne(e){return(await this.fetch({...e,limit:1}))[0]??null}async fetchById(e,t){const i={collectionName:e,where:[["id","=",t]]};return this.fetchOne(i)}async insert(e,t){var a,o;if(this.kvTx.status==="cancelled")throw new q;if(!e)throw new $(e,"Collection name must be defined");if(!t)throw new ve("The document being inserted is undefined");if(typeof t!="object"||Array.isArray(t))throw new ve("The document being inserted must be an object.");const i=(o=(a=this.schema)==null?void 0:a.collections[e])==null?void 0:o.schema,s=yi(i,t);return s.id||(s.id=C.defaultValue(Qt.Id())),this.getOrCreateCollectionChanges(e).sets.set(s.id,s),i?C.decode(i,s):s}async update(e,t,i){var c,l;if(!e)throw new $(e);if(this.kvTx.status==="cancelled")throw new q;let s;const r=(l=(c=this.schema)==null?void 0:c.collections[e])==null?void 0:l.schema;if(typeof i=="function"){const u=structuredClone(await this.entityStore.getEntity(this.kvTx,e,t));if(!u)throw new Ue(t,e);const d=r?C.decode(r,u):u;s={},await i(ye(d,s,r))}else s=i;if(Wt(s))return;if("id"in s)throw new Ht(`Attempted to update the id of an entity in the ${e} to ${s.id}. The 'id' attribute of an entity is immutable and cannot be updated.`);const a=this.getOrCreateCollectionChanges(e),o=a.sets.get(t);s=r?C.encode(r,s):s,o&&(s=z({},o,s)),a.sets.set(t,s)}async delete(e,t){if(!e)throw new $(e);if(this.kvTx.status==="cancelled")throw new q;const i=this.getOrCreateCollectionChanges(e),s=i.sets.get(t);if(s&&"id"in s){i.sets.delete(t);return}s&&i.sets.delete(t),i.deletes.add(t)}getOrCreateCollectionChanges(e){return this.changes[e]||(this.changes[e]={sets:new Map,deletes:new Set}),this.changes[e]}}class fi{constructor(e,t={}){f(this,"changes");f(this,"baseStore");this.changes=t,this.baseStore=e}async applyChanges(e,t,i){return this.baseStore.applyChanges(e,t,i)}async getEntity(e,t,i){const s=await this.baseStore.getEntity(e,t,i);if(!this.changes[t])return s;const r=this.changes[t],a=r.deletes.has(i);return he(s,a,r.sets.get(i))}async*getEntitiesInCollection(e,t){yield*qe(this.baseStore.getEntitiesInCollection(e,t),this.changes[t])}async getCollectionStats(e,t){throw new Error("getCollectionStats is not implemented in EntityStoreWithChanges")}}function ye(n,e,t){return new Proxy(n,{get(i,s){const r=(t==null?void 0:t.type)==="record"?t.properties[s]:((t==null?void 0:t.type)==="json",t);return i[s]instanceof Set?(e[s]||(e[s]={}),hi(i[s],e[s],r)):typeof i[s]=="object"&&!(i[s]instanceof Date)&&i[s]!==null?(e[s]||(e[s]={}),ye(i[s],e[s],r)):Reflect.get(i,s)},set(i,s,r){if(typeof s=="symbol")return!0;let a=r;if(r instanceof Set){let o={};if(i[s]instanceof Set)for(const c of i[s])o[c]=!1;for(const c of r)o[c]=!0;a=o}else if(r===void 0)a=null;else if(r instanceof Date)a=r.toISOString();else if(typeof r=="object"&&r!==null&&!Array.isArray(r)){if(e[s]||(e[s]={}),a={},typeof i[s]=="object"&&i[s]!==null)for(const o in i[s])a[o]=null;for(const o in r)a[o]=r[o]}return e[s]=a,Reflect.set(i,s,r)},deleteProperty(i,s){return typeof s=="symbol"||(e[s]=null,i[s]=null),!0}})}function hi(n,e,t){const i=r=>t?C.encode(t.items,r):r,s={add(r){n.has(r)||(e[i(r)]=!0)},clear(){for(const r of n)e[i(r)]=!1},delete(r){n.has(r)&&(e[i(r)]=!1)}};return new Proxy(n,{get(r,a){return typeof r[a]!="function"?Reflect.get(r,a):function(...o){var c;return(c=s[a])==null||c.call(s,...o),r[a](...o)}}})}function yi(n,e){if(!n)return e;const t=C.struct(n),i=C.assign(n,t,e);return et(i),C.encode(n,i)}function et(n){for(const e in n)if(n[e]===void 0)delete n[e];else{if(typeof n[e]!="object")continue;n[e]!==null&&!Array.isArray(n[e])&&!(n[e]instanceof Date)&&!(n[e]instanceof Set)&&et(n[e])}}function gi(n){return typeof n=="string"&&n.startsWith("$")}function tt(n,e){const t={};for(const i in n){const s=n[i],r=e[i];if(r===void 0)return;if(typeof s=="object"){const a=tt(s,r);if(a===void 0)return;Object.assign(t,a);continue}if(gi(s)){const a=s.slice(1);t[a]=r;continue}if(s!==r)return}return t}class pi{constructor(e,t){f(this,"vars");f(this,"db");f(this,"_roles");this.db=e,this.vars=Object.freeze(t)}get roles(){return nt(this.db.schema,this.vars)??[]}}function mi(n,e){const t=new pi(n,e);return new Proxy(n,{get(s,r,a){return r==="session"?t:Reflect.get(s,r,a)},set:Reflect.set,deleteProperty:Reflect.deleteProperty})}function nt(n,e){if(!n)return;const t=n.roles;if(!t)return[];const i=[];for(const[s,r]of Object.entries(t)){const a=tt(r.match,e);a!==void 0&&i.push({key:s,roleVars:a})}return i}function xe(n){return!n||n.length===0}function wi(n,e){if(xe(n)&&xe(e))return!0;if((n==null?void 0:n.length)!==(e==null?void 0:e.length))return!1;const t=n==null?void 0:n.map(({key:a})=>a),i=e==null?void 0:e.map(({key:a})=>a);if(t!=null&&t.some(a=>!(i!=null&&i.includes(a))))return!1;const s=Ae(n),r=Ae(e);return t==null?void 0:t.every(a=>s[a]===r[a])}function Ae(n){return n.reduce((e,{key:t,roleVars:i})=>(e[t]=Ut(i),e),{})}function it(n){const e={};return"x-triplit-user-id"in n&&(e.SESSION_USER_ID=n["x-triplit-user-id"]),Object.assign(e,n),"scope"in e&&!("_scope"in e)&&typeof e.scope=="string"&&(e._scope=e.scope.split(" ")),e}function st(n,e=[],t=[],i=[]){for(const[s,r]of Object.entries(n.properties))r.type==="date"&&t.push([...e,s]),r.type==="set"&&i.push([[...e,s],r.items.type]),r.type==="record"&&st(r,[...e,s],t,i);return{datePaths:t,setPaths:i}}function Fe(n){if(!n)return;const e=new Map;for(const[t,i]of Object.entries(n.collections))st(i.schema),e.set(t,{fromDB:s=>C.decode(i.schema,s)});return e}function N(n){return new v(n)}class v{constructor(e,t){f(this,"collectionName");f(this,"select");f(this,"where");f(this,"limit");f(this,"order");f(this,"include");f(this,"after");f(this,"vars");this.collectionName=e,t&&(this.select=t.select,this.where=t.where,this.limit=t.limit,this.order=t.order,this.include=t.include,this.after=t.after,this.vars=t.vars)}Select(e){const t=e;return new v(this.collectionName,{...this,select:t})}Where(...e){const t=R().where(this,...e);return new v(this.collectionName,{...this,where:t})}Id(e){const t=this.where?this.where.filter(i=>!Ve(i)):[];return t.push(["id","=",e]),new v(this.collectionName,{...this,where:t})}Limit(e){const t=e;return new v(this.collectionName,{...this,limit:t})}Order(...e){const t=R().order(this,...e);return new v(this.collectionName,{...this,order:t})}After(e,t){const i=R().after(this,e,t);return new v(this.collectionName,{...this,after:i})}Vars(e){const t=e;return new v(this.collectionName,{...this,vars:t})}Include(e,t){typeof t=="function"&&(t=t(rt));const i=R().include(this,e,t);return new v(this.collectionName,{...this,include:i})}SubqueryOne(e,t){typeof t=="function"&&(t=t(N));const i=R().include(this,e,{subquery:t,cardinality:"one"});return new v(this.collectionName,{...this,include:i})}SubqueryMany(e,t){typeof t=="function"&&(t=t(N));const i=R().include(this,e,{subquery:t,cardinality:"many"});return new v(this.collectionName,{...this,include:i})}}function rt(n){return new I(n)}class I{constructor(e,t){f(this,"_extends");f(this,"select");f(this,"where");f(this,"limit");f(this,"order");f(this,"include");this._extends=e,t&&(this.select=t.select,this.where=t.where,this.limit=t.limit,this.order=t.order,this.include=t.include)}Select(e){const t=e;return new I(this._extends,{...this,select:t})}Where(...e){const t=R().where(this,...e);return new I(this._extends,{...this,where:t})}Id(e){const t=this.where?this.where.filter(i=>!Ve(i)):[];return t.push(["id","=",e]),new I(this._extends,{...this,where:t})}Limit(e){const t=e;return new I(this._extends,{...this,limit:t})}Order(...e){const t=R().order(this,...e);return new I(this._extends,{...this,order:t})}Include(e,t){typeof t=="function"&&(t=t(rt));const i=R().include(this,e,t);return new I(this._extends,{...this,include:i})}SubqueryOne(e,t){typeof t=="function"&&(t=t(N));const i=R().include(this,e,{subquery:t,cardinality:"one"});return new I(this._extends,{...this,include:i})}SubqueryMany(e,t){typeof t=="function"&&(t=t(N));const i=R().include(this,e,{subquery:t,cardinality:"many"});return new I(this._extends,{...this,include:i})}}function bi(n){return Array.isArray(n)&&n[0]===void 0}function Si(n){return ue(n)}function at(n){return Array.isArray(n)&&n.every(e=>Bt(e))}function Ci(n){return n.length===1&&at(n[0])}const R=()=>({where:(n,...e)=>{let t=[];if(bi(e))return n.where??[];if(Si(e))t=[e];else if(at(e))t=e;else if(Ci(e))t=e[0];else throw new ee("where",e);return[...n.where??[],...t]},order:(n,...e)=>{if(!e[0])return n.order??[];let t=[];if(e.length===2&&e.every(i=>typeof i=="string"))t=[[...e]];else if(e.length===1&&e[0]instanceof Array&&e[0].every(i=>i instanceof Array))t=e[0];else if(e.every(i=>i instanceof Array))t=e;else throw new ee("order",e);return[...n.order??[],...t]},include(n,e,t){return{...n.include,[e]:t??null}},after(n,e,t){if(!e)return;if(!n.order)throw new Vt(e);const i=n.order.map(s=>s[0]);if(e instanceof Array)return[e,t??!1];if(typeof e=="object")return[i.map(s=>A.Get(e,s)),t??!1];throw new ee("after",e)}});function vi(n){if(m(n))return"schema is not defined";if(typeof n!="object")return"schema is not an object";const e=Ei(n.roles);if(e)return`schema roles definition is invalid: ${e}`;const t=Ti(n.collections);if(t)return`schema collections definition is invalid: ${t}`}function Ei(n){if(!m(n)){if(typeof n!="object")return"roles is not an object";for(const e in n){const t=Ui(e);if(t)return`role "${e}" is invalid: ${t}`;const i=n[e],s=ki(i);if(s)return`role "${e}" is invalid: ${s}`}}}function ki(n){if(m(n))return"role is not defined";if(typeof n!="object")return"role is not an object";if(m(n.match))return"matcher is not defined";if(typeof n.match!="object")return"matcher is not an object"}function Ti(n,e){if(m(n))return"collections is not defined";if(typeof n!="object")return"collections is not an object";for(const t in n){const i=Ri(t);if(i)return`"${t}" is not a valid collection name: ${i}`;const s=n[t],r=Ii(s);if(r)return`"${t}" is not a valid collection: ${r}`}}function Ri(n){if(typeof n!="string")return"collection name is not a string";if(n.length===0)return"collection name is empty";if(n.startsWith("_"))return"collection name cannot start with an underscore";if(/^[0-9]/.test(n))return"collection name cannot start with a numeric character";if(!/^[a-zA-Z0-9_]+$/.test(n))return"collection name contains invalid characters - only alphanumeric characters and underscores are allowed."}function Ii(n,e){if(m(n))return"collection is not defined";if(typeof n!="object")return"collection is not an object";const t=Pi(n.schema);if(t)return`collection schema is invalid: ${t}`;if("relationships"in n){const i=Mi(n.relationships,n);if(i)return`collection relationships is invalid: ${i}`}if("permissions"in n){const i=Wi(n.permissions);if(i)return`collection permissions is invalid: ${i}`}}function Pi(n){if(m(n))return"schema is not defined";if(typeof n!="object")return"schema is not an object";const e=ct(n);if(e)return`${e}`;if(m(n.properties.id))return'primary key field "id" is not defined';const t=lt(n.properties.id);if(t)return`primary key field "id" is invalid: ${t}`}function ot(n){return m(n)?"type is not defined":typeof n!="object"?"type is not a DataType":n.type==="boolean"?Oi(n):n.type==="date"?xi(n):n.type==="json"?Ai(n):n.type==="number"?Fi(n):n.type==="record"?ct(n):n.type==="set"?$i(n):n.type==="string"?lt(n):`type "${n.type}" is not recognized`}function Oi(n){if(n.type!=="boolean")return"not a boolean type";const e=F(n.config);if(e)return`type boolean is invalid: ${e}`}function xi(n){if(n.type!=="date")return"not a date type";const e=F(n.config);if(e)return`type date is invalid: ${e}`}function Ai(n){if(n.type!=="json")return"not a json type";const e=F(n.config);if(e)return`type json is invalid: ${e}`}function Fi(n){if(n.type!=="number")return"not a number type";const e=F(n.config);if(e)return`type number is invalid: ${e}`}function ct(n){if(n.type!=="record")return"not a record type";const e=F(n.config);if(e)return`type record is invalid: ${e}`;if(m(n.properties))return"type record is missing properties";if(typeof n.properties!="object")return"type record properties is not an object";for(const t in n.properties){const i=_i(t);if(i)return`type record property "${t}" is invalid: ${i}`;const s=n.properties[t],r=ot(s);if(r)return`type record property "${t}" is invalid: ${r}`}}function $i(n){if(n.type!=="set")return"not a set type";const e=F(n.config);if(e)return`type set is invalid: ${e}`;if(m(n.items))return"type set is missing items";const t=ot(n.items);if(t)return`type set items is invalid: ${t}`;if(!zt(n.items))return"type set items must be a primitive type"}function lt(n){var t;if(n.type!=="string")return"not a string type";const e=F(n.config);if(e)return`type string is invalid: ${e}`;if(!m((t=n.config)==null?void 0:t.enum)){if(!Array.isArray(n.config.enum))return"type string enum is not an array";for(const i of n.config.enum)if(typeof i!="string")return"type string enum value is not a string"}}function _i(n){if(m(n))return"property name is not defined";if(typeof n!="string")return"property name is not a string";if(n.length===0)return"property name is empty";if(/^[0-9]/.test(n))return"property name cannot start with a numeric character";if(!/^[a-zA-Z0-9_]+$/.test(n))return"property name contains invalid characters - only alphanumeric characters and underscores are allowed."}function F(n){if(m(n))return;if(typeof n!="object")return"type config is not an object";if(!m(n.nullable)&&typeof n.nullable!="boolean")return"option nullable is invalid";if(!m(n.optional)&&typeof n.optional!="boolean")return"option optional is invalid";const e=Ni(n.default);if(e)return`option default is invalid: ${e}`}function Ni(n){if(!m(n)){if(typeof n=="object"){const e=Di(n);if(e)return`default value is invalid: ${e}`}else if(typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")return"default value is not a primitive"}}function Di(n){if(typeof n!="object")return"default function format is invalid";if(m(n.func))return"default function is missing func identifier";const e=n.func;if(!ji(e))return`default function ${n.func} is not recognized`;if(e==="now"&&!m(n.args))return'default function "now" has no args';if(e==="uuid"&&!m(n.args)){if(!Array.isArray(n.args))return'default function "uuid" args is not an array';if(n.args.length>0&&typeof n.args[0]!="number")return'default function "uuid" arg[0] is not a number'}if(e==="Set.empty"&&!m(n.args))return'default function "Set.empty" has no args'}function ji(n){return Kt.includes(n)}function Mi(n,e){if(!m(n)){if(typeof n!="object")return"relationships is not an object";for(const t in n){const i=Li(t,e);if(i)return`relationship "${t}" is invalid: ${i}`;const s=n[t],r=Qi(s);if(r)return`relationship "${t}" is invalid: ${r}`}}}function Li(n,e){if(m(n))return"relationship name is not defined";if(typeof n!="string")return"relationship name is not a string";if(n.length===0)return"relationship name is empty";if(n.startsWith("_"))return"relationship name cannot start with an underscore";if(/^[0-9]/.test(n))return"relationship name cannot start with a numeric character";if(!/^[a-zA-Z0-9_]+$/.test(n))return"relationship name contains invalid characters - only alphanumeric characters and underscores are allowed.";if(e.schema.properties[n])return"relationship name matches a property name"}function Qi(n){if(m(n))return"relationship is not defined";if(typeof n!="object")return"relationship is not an object";if(m(n.cardinality))return"cardinality is not defined";if(n.cardinality!=="one"&&n.cardinality!=="many")return"cardinality is invalid";if(m(n.query))return"query is not defined";if(typeof n.query!="object")return"query is not an object"}function Wi(n,e){if(!m(n)){if(typeof n!="object")return"permissions is not an object";for(const t in n){const i=n[t],s=Hi(i);if(s)return`permissions for role "${t}" is invalid: ${s}`}}}function Hi(n){if(!m(n)){if(typeof n!="object")return"not an object";if(n.read){const e=M(n.read);if(e)return`"read" permission is invalid: ${e}`}if(n.insert){const e=M(n.insert);if(e)return`insert permission is invalid: ${e}`}if(n.update){const e=M(n.update);if(e)return`update permission is invalid: ${e}`}if(n.postUpdate){const e=M(n.postUpdate);if(e)return`postUpdate permission is invalid: ${e}`}if(n.delete){const e=M(n.delete);if(e)return`delete permission is invalid: ${e}`}}}function M(n){if(!m(n)){if(typeof n!="object")return"permission is not an object";m(n.filter)}}function Ui(n){if(m(n))return"role name is not defined";if(typeof n!="string")return"role name is not a string";if(n.length===0)return"role name is empty";if(n.startsWith("_"))return"role name cannot start with an underscore";if(/^[0-9]/.test(n))return"role name cannot start with a numeric character";if(!/^[a-zA-Z0-9_]+$/.test(n))return"role name contains invalid characters - only alphanumeric characters and underscores are allowed."}class $e{constructor(e={}){f(this,"entityStore");f(this,"clock");f(this,"session");f(this,"globalVars");f(this,"logger");f(this,"subscribedQueries",new Map);f(this,"clientId");f(this,"ivm");f(this,"schema");f(this,"onCommitListeners",new Set);f(this,"kv");f(this,"typeConverters");f(this,"schemaChangeListeners",[]);this.logger=Gt,this.globalVars=e.variables??{},this.kv=e.kv??new de,this.entityStore=e.entityStore??new ae,this.clientId=e.clientId||"test-client",this.clock=new _({clientId:this.clientId}),this.ivm=e.ivm??new Jt(this),this.schema=e.schema,this.typeConverters=Fe(this.schema)}static async getSchemaFromStorage(e){const i=await new ae().getEntity(e,"_metadata","_schema");if(Yt(i))return;const s={...i};return delete s.id,s}getSchema(){return this.schema}subscribe(e,t,i,s={}){var o;const r=x(e,(o=this.schema)==null?void 0:o.collections,this.systemVars,this.session,{applyPermission:s.skipRules?void 0:"read"}),a=({results:c})=>{t(H(c,r,"many",this.typeConverters),s.queryKey)};return this.ivm.subscribe(r,a,i)}subscribeRaw(e,t,i,s={}){const r=({results:a})=>{t(a,s.queryKey)};return this.ivm.subscribe(e,r,i)}subscribeWithChanges(e,t,i,s={}){var o;const r=x(e,(o=this.schema)==null?void 0:o.collections,this.systemVars,this.session,{applyPermission:s.skipRules?void 0:"read"}),a=({results:c,changes:l})=>{t({results:H(c,r,"many",this.typeConverters),changes:l})};return this.ivm.subscribe(r,a,i)}subscribeChanges(e,t,i={}){var o;const s=x(e,(o=this.schema)==null?void 0:o.collections,this.systemVars,this.session,{applyPermission:i.skipRules?void 0:"read"});let r=!0;const a=async({changes:c})=>{var u;let l=c;if(i.queryState&&r){const d={},h={};for(const[y,g]of Object.entries(i.queryState.entityIds))for(const p of g){if(!Bi(c,y,p)){h[y]||(h[y]=new Set),h[y].add(p);continue}const b=await this.entityStore.metadataStore.getTimestampForEntity(this.kv,y,p);b&&_.compare(b,i.queryState.timestamp)<0&&(d[y]||(d[y]=new Set),d[y].add(p))}l={};for(const y in c){l[y]={sets:new Map,deletes:c[y].deletes};for(const[g,p]of c[y].sets)(u=d[y])!=null&&u.has(g)||l[y].sets.set(g,p)}for(const[y,g]of Object.entries(h)){const p=new Set(g);l[y]||(l[y]={sets:new Map,deletes:new Set});const b=await this.fetchChanges({collectionName:y,where:[["id","in",Array.from(g)]]});for(const[T,P]of b[y].sets)p.delete(T),l[y].sets.set(T,P);for(const T of p)l[y].deletes.add(T)}}t(l,i.queryKey),r=!1};return this.ivm.subscribe(s,a,i.errorCallback)}async fetch(e,t){var a;const i=x(e,(a=this.schema)==null?void 0:a.collections,this.systemVars,this.session,{applyPermission:t!=null&&t.skipRules?void 0:"read"});let r=await new Q(this.kv,this.entityStore).fetch(i);return H(r,i,"many",this.typeConverters)}async rawFetch(e,t){return new Q(this.kv,this.entityStore).fetch(e,t)}async fetchChanges(e,t){var a;const i=x(e,(a=this.schema)==null?void 0:a.collections,this.systemVars,this.session,{applyPermission:t!=null&&t.skipRules?void 0:"read"}),s=await this.rawFetch(i);return Be(s,i)}async fetchOne(e,t){e={...e,limit:1};const s=(await this.fetch(e,t))[0];return s||null}async fetchById(e,t,i){const s=this.query(e).Id(t);return this.fetchOne(s,i)}async insert(e,t,i){return this.transact(async s=>await s.insert(e,t),{skipRules:(i==null?void 0:i.skipRules)??!1})}async update(e,t,i,s){return this.transact(async r=>{await r.update(e,t,i)},{skipRules:(s==null?void 0:s.skipRules)??!1})}async delete(e,t,i){return this.transact(async s=>{await s.delete(e,t)},{skipRules:(i==null?void 0:i.skipRules)??!1})}onCommit(e){return this.onCommitListeners.add(e),()=>{this.onCommitListeners.delete(e)}}updateQueryViews(){return this.ivm.updateViews()}broadcastToQuerySubscribers(){return this.ivm.flushChangesToListeners()}async transact(e,t){let i,s;const r=this.kv.transact();try{const a=new di({schema:this.schema,kvTx:r,entityStore:this.entityStore,systemVars:this.systemVars,session:this.session,typeConverters:this.typeConverters,skipRules:!!(t!=null&&t.skipRules)});s=await e(a),i=await this.entityStore.applyChanges(r,a.changes,{checkWritePermission:t!=null&&t.skipRules?void 0:this.checkWritePermission.bind(this),entityChangeValidator:this.validateEntityChange.bind(this)}),await r.commit()}catch(a){throw r.cancel(),a}await this.ivm.bufferChanges(i);for(const a of this.onCommitListeners)a(i);return s}async applyChanges(e,t){const i=this.kv.transact(),s=await this.entityStore.applyChanges(i,e,{checkWritePermission:t!=null&&t.skipRules?void 0:this.checkWritePermission.bind(this),entityChangeValidator:this.validateEntityChange.bind(this)});await i.commit(),await this.ivm.bufferChanges(s)}async applyChangesWithTimestamp(e,t,i){const s=this.kv.transact(),r=await this.entityStore.applyChangesWithTimestamp(s,e,t,{checkWritePermission:i!=null&&i.skipRules?void 0:this.checkWritePermission.bind(this),entityChangeValidator:this.validateEntityChange.bind(this)});await s.commit(),await this.ivm.bufferChanges(r)}async getCollectionStats(){return this.entityStore.getCollectionStats(this.kv,this.schema?Object.keys(this.schema.collections):void 0)}async overrideSchema(e,t){const i=await this._overrideSchema(e,t);for(const s of this.schemaChangeListeners)await s(i);return i}async _overrideSchema(e,{failOnBackwardsIncompatibleChange:t=!1}={}){let i=this.schema;const s=vi(e);if(s)return{successful:!1,invalid:s,issues:[],diff:[],oldSchema:i,newSchema:e};if(!i)return await this.updateSchema(e),{successful:!0,invalid:void 0,issues:[],diff:[],oldSchema:i,newSchema:e};let r=[];const a=Fn(i,e);return a.length===0?{successful:!0,invalid:void 0,issues:r,diff:a,oldSchema:i,newSchema:e}:(r=await Dn(o=>this.fetch.bind(this)(o,{skipRules:!0}),a),t&&r.length>0?{successful:!1,invalid:void 0,issues:r,diff:a,oldSchema:i,newSchema:e}:r.length>0&&r.some(o=>o.violatesExistingData)?{successful:!1,invalid:void 0,issues:r,diff:a,oldSchema:i,newSchema:e}:(a.length>0&&this.logger.info(`applying ${a.length} changes to schema`),await this.updateSchema(e),{successful:!0,invalid:void 0,issues:r,diff:a,oldSchema:i,newSchema:e}))}async setMetadata(e,t){const i=this.kv.scope(["_metadata"]),s=this.kv.transact();await i.set(e,t),await s.commit()}async getMetadata(e){return await this.kv.scope(["_metadata"]).get(e)}async updateSchema(e){const t=this.kv.transact();await this.entityStore.dataStore.applyChanges(t,{_metadata:{sets:new Map([["_schema",{id:"_schema",...e}]]),deletes:new Set}},{checkWritePermission:void 0,entityChangeValidator:void 0}),await t.commit(),this.schema=e,this.typeConverters=Fe(this.schema)}withSessionVars(e){return mi(this,it(e))}onSchemaChange(e){return this.schemaChangeListeners.push(e),()=>{this.schemaChangeListeners=this.schemaChangeListeners.filter(t=>t!==e)}}query(e){return new v(e)}Query(e){return this.query(e)}async clear(e){if(await this.kv.clear(),e!=null&&e.full){await this.ivm.clear(),this.schema=void 0;return}this.schema&&await this.updateSchema(this.schema),this.ivm.resetSubscriptions()}updateGlobalVariables(e){this.globalVars=e}get systemVars(){var e;return{$global:this.globalVars,$session:((e=this.session)==null?void 0:e.vars)??{}}}validateEntityChange(e,t,{ignoreRequiredProperties:i=!1}){var o,c;const s=(o=this.schema)==null?void 0:o.collections;if(!s)return;const r=(c=s[e])==null?void 0:c.schema;if(!r)return;const a=C.validateEncoded(r,t,{partial:i});if(!a.valid)throw new Zt("record",JSON.stringify(t),a.error)}async checkWritePermission(e,t,i,s){var u,d,h;if(!ze((u=this.schema)==null?void 0:u.collections,t))return;const o=x({collectionName:t},(d=this.schema)==null?void 0:d.collections,this.systemVars,this.session,{applyPermission:s}).where;if(!o||o.length===0)return;const c=new Q(e,this.entityStore);if(!await Xt(i,o,c))throw new qt(t,i.id,s,((h=this.session)==null?void 0:h.roles)??[])}}async function Vi(n){let e;n.kv&&(e=await $e.getSchemaFromStorage(n.kv));const t=new $e({...n,schema:e});if(n.schema){const i=await t.overrideSchema(n.schema,{failOnBackwardsIncompatibleChange:!0});if(Vn(i,{logger:t.logger}),!i.successful)throw new Error("Schema change failed. Review the issues above for more information.")}else e&&await t.updateSchema(e);return t}function Bi(n,e,t){return n[e]&&(n[e].sets.has(t)||n[e].deletes.has(t))}function H(n,e,t,i){if(n===null)return null;const s=i==null?void 0:i.get(e.collectionName),r=c=>(s==null?void 0:s.fromDB(c))??c,a=c=>{if(!e.select)return c;const l={};for(const u of e.select)A.Set(l,u,A.Get(c,u));return l},o=c=>{const l=r(a(c.data)),u=e.include&&Object.entries(e.include).reduce((d,[h,y])=>(c.subqueries[h]!==void 0&&(d[h]=H(c.subqueries[h],y.subquery,y.cardinality,i)),d),{});return{...l,...u}};return t==="one"?o(n):n.map(o)}function zi(n,e){return n?C.serialize(n,e,"decoded"):e}function ce(n,e,t){const i=e==null?void 0:e[n.collectionName],s=i==null?void 0:i.schema,r=n.include?Object.keys(n.include):[];function a(o){if(!o)return null;const c={};for(const l of r)c[l]=ce(Ki(i,l,n.include[l],"deserialize"),e,o[l]),delete o[l];o=le(s,o);for(const l of r)o[l]=c[l];return o}if(Array.isArray(t))for(let o=0;o<t.length;o++)t[o]=a(t[o]);else t=a(t);return t}function le(n,e){return n?C.deserialize(n,e,"decoded"):e}function Ki(n,e,t,i){var s,r;if(Y(t)){if(!n)throw new S(`Cannot ${i} inclusion '${e}' without schema`);const a=(s=n.relationships)==null?void 0:s[e];if(!a)throw new S(`Cannot ${i} inclusion '${e}', no relation found for '${e}'`);return a.query}if(Ze(t)){if(!n)throw new S(`Cannot ${i} inclusion '${e}' without schema`);const{_extends:a,...o}=t,c=(r=n.relationships)==null?void 0:r[a];if(!c)throw new S(`Cannot ${i} inclusion '${e}', no relation found for '${a}'`);return{...c.query,...o}}if(Ye(t))return t.subquery;throw new S(`Failed to ${i} inclusion '${e}': invalid format`)}class _e{constructor(e=[]){f(this,"storagePrefix");this.storagePrefix=e}async clear(e){const t=e.scope(this.storagePrefix),i=t.scan({prefix:[]});for await(const[s]of i)await t.delete(s)}async write(e,t){const i=e.scope(this.storagePrefix);for(const s in t){const r=t[s];for(const a of r.deletes){const o=await i.get([s,"sets",a]);o&&(await i.delete([s,"sets",a]),"id"in o)||await i.set([s,"deletes",a],!0)}for(const[a,o]of r.sets){const c=[s,"sets",a],l=await i.get(c);let u=o;l&&(u=z(l,o)),await i.set(c,u)}}}async getChanges(e){const i=e.scope(this.storagePrefix).scan({prefix:[]});let s={};for await(const[r,a]of i){const o=r[1];if(o==="sets"){const[c,l,u]=r;s[c]||(s[c]={sets:new Map,deletes:new Set});let d=a;const h=s[c].sets.get(u);h&&(d=z({},h,a)),s[c].sets.set(u,d)}if(o==="deletes"){const[c,l,u]=r;s[c]||(s[c]={sets:new Map,deletes:new Set}),s[c].deletes.add(u)}}return s||{}}async getChangesForCollection(e,t){const i=e.scope(this.storagePrefix),s={sets:new Map,deletes:new Set};for await(const[r,a]of i.scan({prefix:[t,"sets"]})){const[o]=r;s.sets.set(o,a)}for await(const[r]of i.scan({prefix:[t,"deletes"]})){const[a]=r;s.deletes.add(a)}if(!(s.sets.size===0&&s.deletes.size===0))return s}async getChangesForEntity(e,t,i){const s=e.scope(this.storagePrefix),r=await s.get([t,"sets",i]),a=await s.get([t,"deletes",i]);if(!(r===void 0&&a===void 0))return{update:r,delete:a!==void 0}}async isEmpty(e){const t=await this.getChanges(e);return Object.keys(t).length===0}async clearChangesForEntity(e,t,i){const s=e.scope(this.storagePrefix);await s.delete([t,"sets",i]),await s.delete([t,"deletes",i])}}class Gi{constructor(e){f(this,"storage");f(this,"doubleBuffer");f(this,"store");this.storage=e,this.doubleBuffer=new en(new _e(["buf0"]),new _e(["buf1"])),this.store=new ae}get metadataStore(){return this.store.metadataStore}get dataStore(){return this.store.dataStore}async applyChanges(e,t){return await this.doubleBuffer.write(e,t),t}async applyChangesWithTimestamp(e,t,i,s){const r=await this.store.applyChangesWithTimestamp(e,t,i,s),a=await this.doubleBuffer.getChanges(e);for(const o in a){const c=a[o],l=r[o];if(l){for(const u of c.deletes)l.deletes.delete(u),l.sets.delete(u);for(const[u,d]of c.sets){l.deletes.delete(u);const h=l.sets.get(u);h&&l.sets.set(u,{...h,...d})}}}return r}async getEntity(e,t,i){const s=await this.store.getEntity(e,t,i),r=await this.doubleBuffer.getChangesForEntity(e,t,i);return he(s,!!(r!=null&&r.delete),r==null?void 0:r.update)}async getCollectionStats(e){throw new Error("Method not implemented.")}async*getEntitiesInCollection(e,t){yield*qe(this.store.getEntitiesInCollection(e,t),await this.doubleBuffer.getChangesForCollection(e,t))}}class Ne{constructor(){f(this,"data",new Map)}get(e,t){var i;return t===void 0?this.data.get(e):(i=this.data.get(e))==null?void 0:i.get(t)}set(e,t,i){this.data.has(e)||this.data.set(e,new Map),this.data.get(e).set(t,i)}delete(e,t){var i;return((i=this.data.get(e))==null?void 0:i.delete(t))??!1}has(e,t){var i;return t===void 0?this.data.has(e):((i=this.data.get(e))==null?void 0:i.has(t))??!1}keys(){return this.data.keys()}values(){return this.data.values()}entries(){return this.data.entries()}[Symbol.iterator](){return this.entries()}}function L(n,e){const t=Ji(n);return t?((e==null?void 0:e.split("."))??[]).reduce((r,a)=>{if(r&&r[a])return r[a]},t):void 0}function Ji(n){if(typeof n!="string")return;const e=n.split(".");if(e.length!==3)return;const t=e[1],i=t.replace(/-/g,"+").replace(/_/g,"/").padEnd(Math.ceil(t.length/4)*4,"=");try{const s=typeof atob=="function"?atob(i):Buffer.from(i,"base64").toString("binary"),r=decodeURIComponent(Array.from(s,a=>"%"+a.charCodeAt(0).toString(16).padStart(2,"0")).join(""));return JSON.parse(r)}catch{return}}function De(n){return n.exp===void 0?!1:n.exp*1e3<Date.now()}const je="query-state";function Yi(n){for(const e in n)if(Object.hasOwn(n,e))return!1;return!0}class Zi{constructor(e,t){f(this,"transport");f(this,"client");f(this,"connectionChangeHandlers",new Set);f(this,"messageReceivedSubscribers",new Set);f(this,"messageSentSubscribers",new Set);f(this,"sessionErrorSubscribers",new Set);f(this,"entitySyncErrorSubscribers",new Ne);f(this,"entitySyncSuccessSubscribers",new Ne);f(this,"onFailureToSyncWritesSubscribers",new Set);f(this,"logger");f(this,"syncInProgress",!1);f(this,"reconnectTimeoutDelay",250);f(this,"reconnectTimeout");f(this,"serverReady",!1);f(this,"queries",new Map);f(this,"clientId",null);f(this,"connectionAbort",!1);f(this,"lastParamsHash");if(this.client=e,this.logger=t.logger,this.client.onConnectionOptionsChange(i=>{this.connectionStatus==="OPEN"&&("serverUrl"in i||"token"in i&&!i.tokenRefresh)&&(this.logger.warn("You are updating the connection options while the connection is open. To avoid unexpected behavior the connection will be closed and you should call `connect()` again after the update. To hide this warning, call `disconnect()` before updating the connection options."),this.disconnect())}),this.transport=t.transport??new tn,this.transport.onConnectionChange(i=>{(i==="CLOSING"||i==="CLOSED")&&this.lastParamsHash!==void 0&&(this.lastParamsHash=void 0)}),t.pingInterval){const i=setInterval(()=>{this.connectionStatus==="OPEN"&&this.serverReady&&this.sendMessage({type:"PING",payload:{}})},t.pingInterval*1e3);typeof i=="object"&&"unref"in i&&i.unref()}}async sendChanges(e){this.sendMessage({type:"CHANGES",payload:{changes:Ee.serialize(e)}})}async syncWrites(){return this.client.awaitReady&&await this.client.awaitReady,this.syncInProgress?{didSync:!1,syncFailureReason:"Sync in progress"}:this.connectionStatus!=="OPEN"?{didSync:!1,syncFailureReason:"Connection not open"}:this.serverReady?(await this.client.db.entityStore.doubleBuffer.getLockedBuffer().isEmpty(this.client.db.kv)&&this.client.db.entityStore.doubleBuffer.lockAndSwitchBuffers(),await this.trySyncLockedBuffer(),{didSync:!0}):{didSync:!1,syncFailureReason:"Server not ready"}}async trySyncLockedBuffer(){this.syncInProgress=!0;try{const e=await this.client.db.entityStore.doubleBuffer.getLockedBuffer().getChanges(this.client.db.kv);if(Yi(e))this.syncInProgress=!1;else return this.syncInProgress=!0,this.sendChanges(e)}catch(e){throw this.syncInProgress=!1,e}}async createRollbackBufferFromChanges(e){const t={};for(const[i,{sets:s,deletes:r}]of Object.entries(e)){t[i]={sets:new Map,deletes:new Set};const a=this.client.db.entityStore.dataStore,o=this.client.db.kv;for(const c of r){const l=await a.getEntity(o,i,c);l&&t[i].sets.set(c,l)}for(const c of s.keys()){if(t[i].sets.has(c))continue;const l=await a.getEntity(o,i,c);l?t[i].sets.set(c,l):t[i].deletes.add(c)}}return t}async clearPendingChangesForEntity(e,t){this.client.awaitReady&&await this.client.awaitReady;const i=this.client.db.kv.transact(),s=await this.client.db.entityStore.doubleBuffer.getUnlockedBuffer().getChangesForEntity(i,e,t),r={[e]:{sets:new Map,deletes:new Set}};s&&(s.delete&&r[e].deletes.add(t),s.update&&r[e].sets.set(t,s.update));const a=await this.createRollbackBufferFromChanges(r);return await this.client.db.entityStore.doubleBuffer.getUnlockedBuffer().clearChangesForEntity(i,e,t),await i.commit(),await this.client.db.ivm.bufferChanges(a),await this.client.db.updateQueryViews(),this.client.db.broadcastToQuerySubscribers(),this.syncWrites()}async clearPendingChangesAll(){this.client.awaitReady&&await this.client.awaitReady;const e=this.client.db.kv.transact(),t=await this.client.db.entityStore.doubleBuffer.getUnlockedBuffer().getChanges(this.client.db.kv),i=await this.createRollbackBufferFromChanges(t);await this.client.db.entityStore.doubleBuffer.getUnlockedBuffer().clear(e),await e.commit(),await this.client.db.ivm.bufferChanges(i),await this.client.db.updateQueryViews(),this.client.db.broadcastToQuerySubscribers()}async updateTokenForSession(e){try{return await fetch(`${this.client.serverUrl}/update-token`,{method:"POST",body:JSON.stringify({clientId:this.clientId}),headers:{"Content-Type":"application/json",Authorization:`Bearer ${e}`}}),!0}catch(t){return console.error(t),this.logger.error("Failed to update token",t),!1}}onSyncMessageReceived(e){return this.messageReceivedSubscribers.add(e),()=>{this.messageReceivedSubscribers.delete(e)}}onSyncMessageSent(e){return this.messageSentSubscribers.add(e),()=>{this.messageSentSubscribers.delete(e)}}onEntitySyncSuccess(e,t,i){return this.entitySyncSuccessSubscribers.set(e,t,i),()=>{this.entitySyncSuccessSubscribers.delete(e,t)}}onEntitySyncError(e,t,i){return this.entitySyncErrorSubscribers.set(e,t,i),()=>{this.entitySyncErrorSubscribers.delete(e,t)}}onFailureToSyncWrites(e){return this.onFailureToSyncWritesSubscribers.add(e),()=>{this.onFailureToSyncWritesSubscribers.delete(e)}}onSessionError(e){return this.sessionErrorSubscribers.add(e),()=>{this.sessionErrorSubscribers.delete(e)}}async getConnectionParams(){var i;this.client.awaitReady&&await this.client.awaitReady;const e=(i=this.client.db.getSchema())==null?void 0:i.collections;return{schema:e?ke(e):void 0,syncSchema:this.client.syncSchema,token:this.client.token,server:this.client.serverUrl}}async isFirstTimeFetchingQuery(e){return this.client.awaitReady&&await this.client.awaitReady,!await this.client.db.getMetadata([je,te(e)])}async markQueryAsSeen(e){return this.client.awaitReady&&await this.client.awaitReady,this.client.db.setMetadata([je,e],!0)}async subscribe(e,t={}){const{onQueryFulfilled:i,onQueryError:s,onQuerySyncStateChange:r}=t,a=te(e),o=this.queries.has(a);o||this.queries.set(a,{params:e,syncState:"NOT_STARTED",syncStateCallbacks:new Set,subCount:0,hasSent:!1,abortController:new AbortController});const c=this.queries.get(a);c.subCount++,r&&c.syncStateCallbacks.add(r);let l;i&&(c.syncState==="FULFILLED"&&i(),l=d=>{d==="FULFILLED"&&i()},c.syncStateCallbacks.add(l));let u;return s&&(u=(d,h)=>{d==="ERROR"&&s(h)},c.syncStateCallbacks.add(u)),o||await this.connectQuery(a),()=>{const d=this.queries.get(a);if(!d){this.disconnectQuery(a);return}if(d.subCount--,l&&d.syncStateCallbacks.delete(l),u&&d.syncStateCallbacks.delete(u),r&&d.syncStateCallbacks.delete(r),d.subCount===0){this.disconnectQuery(a);return}}}async connectQuery(e){var a;if(this.client.awaitReady&&await this.client.awaitReady,!this.queries.has(e))return;const t=this.queries.get(e);if(!t||t.hasSent||t.abortController.signal.aborted||!this.serverReady)return;const i=await this.client.db.getMetadata(["latest_server_timestamp"]);let s;if(i){const o=nn(sn(x(t.params,(a=this.client.db.schema)==null?void 0:a.collections,{},void 0,{applyPermission:void 0}))),l=await new Q(this.client.db.kv,this.client.db.entityStore.dataStore).fetch(o),u=Be(l,o),d=Xi(u);s={timestamp:i,entityIds:d}}const r=this.sendMessage({type:"CONNECT_QUERY",payload:{id:e,params:t.params,state:s}});if(r){t.syncState="IN_FLIGHT";for(const o of t.syncStateCallbacks)o("IN_FLIGHT",void 0);t.hasSent=!0}return r}hasServerRespondedForQuery(e){const t=te(e),i=this.queries.get(t);return(i&&i.syncState==="FULFILLED")??!1}disconnectQuery(e){if(!this.queries.has(e))return;const t=this.queries.get(e);t.hasSent?this.sendMessage({type:"DISCONNECT_QUERY",payload:{id:e}}):t.abortController.abort(),this.queries.delete(e)}async connect(){this.connectionAbort=!1;const e=await this.getConnectionParams();this.createConnection(e)}createConnection(e){if(this.connectionAbort||!this.validateConnectionParamsWithWarning(e))return;const t=ke(e);this.connectionStatus!=="OPEN"&&this.connectionStatus!=="CONNECTING"&&(this.lastParamsHash=void 0),this.lastParamsHash!==t&&(this.lastParamsHash=t,this.transport.connect(e),this.transport.onMessage(this.onMessageHandler.bind(this)),this.transport.onOpen(this.onOpenHandler.bind(this)),this.transport.onClose(this.onCloseHandler.bind(this)),this.transport.onError(this.onErrorHandler.bind(this)),this.transport.onConnectionChange(this.onConnectionChangeHandler.bind(this)))}async initializeSync(){const e=await this.syncWrites();e.didSync||this.logger.warn(`Failed to send changes on initialization: ${e.syncFailureReason}`);for(const[t]of this.queries)this.connectQuery(t)}async onMessageHandler(e){const t=JSON.parse(e.data);this.logger.debug("received",t);for(const i of this.messageReceivedSubscribers)i(t);if(t.type==="ERROR"&&await this.handleErrorMessage(t),t.type==="ENTITY_DATA"){const{changes:i,timestamp:s,forQueries:r}=t.payload,a=Ee.deserialize(i);this.client.awaitReady&&await this.client.awaitReady,await this.client.db.applyChangesWithTimestamp(a,s,{skipRules:!0}),await this.client.db.setMetadata(["latest_server_timestamp"],s);for(const o of r){const c=this.queries.get(o);c&&c.syncState!=="FULFILLED"&&(await this.markQueryAsSeen(o),c.syncState="FULFILLED")}await this.client.db.updateQueryViews(),this.client.db.broadcastToQuerySubscribers();for(const o of r){const c=this.queries.get(o);if(c)for(const l of c.syncStateCallbacks)l("FULFILLED",t.payload)}}if(t.type==="CHANGES_ACK"){this.client.awaitReady&&await this.client.awaitReady;const i=await this.client.db.entityStore.doubleBuffer.getLockedBuffer().getChanges(this.client.db.kv),s=this.client.db.kv.transact();await this.client.db.entityStore.applyChangesWithTimestamp(s,i,t.payload.timestamp,{checkWritePermission:void 0,entityChangeValidator:void 0}),await this.client.db.entityStore.doubleBuffer.getLockedBuffer().clear(s),await s.commit();for(const[r,a]of this.entitySyncSuccessSubscribers){const o=i[r];if(o)for(const[c,l]of a)(o.sets.has(c)||o.deletes.has(c))&&l()}this.syncInProgress=!1,await this.syncWrites()}if(t.type==="CLOSE"){const{payload:i}=t;this.logger.info(`Closing connection${i!=null&&i.message?`: ${i.message}`:"."}`);const{type:s,retry:r}=i;this.closeConnection({type:s,retry:r})}if(t.type==="SCHEMA_REQUEST"){const i=await this.client.getSchema();this.sendMessage({type:"SCHEMA_RESPONSE",payload:{schema:i}})}if(t.type==="READY"){const{payload:i}=t,{clientId:s}=i;this.clientId=s,this.serverReady||(this.serverReady=!0,await this.initializeSync())}}onOpenHandler(){this.logger.info("sync connection has opened",{status:this.connectionStatus}),this.resetReconnectTimeout()}onCloseHandler(e){if(this.resetSyncConnectionState(),this.serverReady=!1,e.reason){let i,s;try{const{type:r,retry:a}=JSON.parse(e.reason);i=r,s=a}catch{i="UNKNOWN",s=!0}if(i==="UNAUTHORIZED"&&this.logger.error("The server has closed the connection because the client is unauthorized. Please provide a valid token."),i==="SCHEMA_MISMATCH"&&this.logger.error("The server has closed the connection because the client schema does not match the server schema. Please update your client schema."),i==="TOKEN_EXPIRED"&&this.logger.error("The server has closed the connection because the token has expired. Fetch a new token from your authentication provider and call `TriplitClient.endSession()` and `TriplitClient.startSession(token)` to restart the session."),i==="ROLES_MISMATCH"&&this.logger.error("The server has closed the connection because the client attempted to update the session with a token that has different roles than the existing token. Call `TriplitClient.endSession()` and `TriplitClient.startSession(token)` to restart the session with the new token."),["ROLES_MISMATCH","TOKEN_EXPIRED","SCHEMA_MISMATCH","UNAUTHORIZED"].includes(i))for(const r of this.sessionErrorSubscribers)r(i);if(!s){this.logger.warn("The connection has closed. Based on the signal, the connection will not automatically retry. If you would like to reconnect, please call `connect()`.");return}}const t=this.connect.bind(this);this.reconnectTimeout=setTimeout(t,this.reconnectTimeoutDelay),this.reconnectTimeoutDelay=Math.min(3e5,this.reconnectTimeoutDelay*2)}onErrorHandler(e){this.logger.error("An error occurred during the connection to the server. Retrying connection..."),this.closeConnection()}onConnectionChangeHandler(e){for(const t of this.connectionChangeHandlers)t(e)}get connectionStatus(){return this.transport.connectionStatus}disconnect(){this.closeConnection({type:"MANUAL_DISCONNECT",retry:!1})}resetQueryState(){this.connectionStatus==="OPEN"&&(this.logger.warn("You are resetting the sync engine while the connection is open. To avoid unexpected behavior the connection will be closed and you should call `connect()` again after resetting. To hide this warning, call `disconnect()` before resetting."),this.disconnect()),this.resetSyncConnectionState()}resetSyncConnectionState(){this.syncInProgress=!1;for(const e of this.queries.values())e.hasSent=!1,e.syncState="NOT_STARTED"}async handleErrorMessage(e){var r;const{error:t,metadata:i,messageType:s}=e.payload;switch(this.logger.error(t.name,i),t.name){case"MalformedMessagePayloadError":case"UnrecognizedMessageTypeError":this.logger.warn("You sent a malformed message to the server. This might occur if your client is not up to date with the server. Please ensure your client is updated.");break;case"QuerySyncError":const a=i==null?void 0:i.queryKey;if(a){const o=this.queries.get(a);if(o){const c=S.fromJson(t);o.syncState="ERROR";for(const l of o.syncStateCallbacks)await l("ERROR",c)}this.disconnectQuery(a)}}if(s==="CHANGES"){this.client.awaitReady&&await this.client.awaitReady;const a=this.client.db.kv.transact(),o=this.client.db.entityStore.doubleBuffer,c=await o.getLockedBuffer().getChanges(a);await o.getLockedBuffer().write(a,await o.getUnlockedBuffer().getChanges(a)),await o.getUnlockedBuffer().clear(a),await a.commit(),o.lockAndSwitchBuffers(),this.syncInProgress=!1;for(const l of this.onFailureToSyncWritesSubscribers)await l(t,c);for(const l in c)for(const[u,d]of c[l].sets){const h=this.entitySyncErrorSubscribers.get(l,u);h&&await h((r=i==null?void 0:i.failures[0])==null?void 0:r.error,d)}}}sendMessage(e){const t=this.transport.sendMessage(e);if(t){this.logger.debug("sent",e);for(const i of this.messageSentSubscribers)i(e)}return t}onConnectionStatusChange(e,t=!1){return this.connectionChangeHandlers.add(e),t&&e(this.transport.connectionStatus),()=>{this.connectionChangeHandlers.delete(e)}}closeConnection(e){this.connectionAbort=!0,this.transport.close(e)}resetReconnectTimeout(){clearTimeout(this.reconnectTimeout),this.reconnectTimeoutDelay=250}async syncQuery(e){try{let t,i;const s=new Promise((a,o)=>{t=a,i=o}),r=this.subscribe(e,{onQueryFulfilled:async()=>{const a=await r;t(void 0),a()}});return s}catch(t){throw t instanceof S?t:t instanceof Error?new Te(e,t.message):new Te(e,"An unknown error occurred.")}}validateConnectionParamsWithWarning(e){const t=[];return e.token||t.push("token"),e.server||t.push("serverUrl"),t.length?(this.logger.warn(`You are attempting to connect but the connection cannot be opened because the required parameters are missing: [${t.join(", ")}].`),!1):!0}}function Xi(n){const e={};for(const[t,i]of Object.entries(n)){const s=[...i.sets.keys(),...i.deletes];e[t]=s}return e}function qi(n){try{const e=JSON.parse(n);return S.fromJson(e)}catch{return new S(`Failed to parse remote error response: ${n}`)}}class es{constructor(e={}){f(this,"options");f(this,"_schemaInitialized",!1);this.options=e}async schema(){return this._schemaInitialized||(this.options.schema||(this.options.schema=await(this.options.schemaFactory?this.options.schemaFactory():void 0)),this._schemaInitialized=!0),this.options.schema}updateOptions(e){this.options={...this.options,...e}}async sendRequest(e,t,i,s={isFile:!1}){const r=this.options.serverUrl;if(!r)throw new S("No server url provided");if(!this.options.token)throw new S("No token provided");const a={Authorization:"Bearer "+this.options.token,"Content-Type":"application/json"},o=JSON.stringify(i);let c;s.isFile&&(c=new FormData,c.append("data",o),delete a["Content-Type"]);const l=await fetch(r+e,{method:t,headers:a,body:s.isFile?c:o});return l.ok?{data:await l.json(),error:void 0}:{data:void 0,error:qi(await l.text())}}async fetch(e){const{data:t,error:i}=await this.sendRequest("/fetch","POST",{query:e});if(i)throw i;return ce(e,await this.schema(),t)}async fetchOne(e){e={...e,limit:1};const{data:t,error:i}=await this.sendRequest("/fetch","POST",{query:e});if(i)throw i;const r=ce(e,await this.schema(),t)[0];return r||null}async fetchById(e,t){const i=this.query(e).Id(t);return this.fetchOne(i)}async insert(e,t){const i=await this.schema(),s=i==null?void 0:i[e].schema,r=s?C.serialize(s,t,"decoded"):t,{data:a,error:o}=await this.sendRequest("/insert","POST",{collectionName:e,entity:r});if(o)throw o;return le(s,a)}async bulkInsert(e){const t=await this.schema();let i=e;if(t){const o={};for(const c in e){const l=c,u=e[l],d=t==null?void 0:t[l].schema;u&&(o[l]=u.map(h=>zi(d,h)))}i=o}const{data:s,error:r}=await this.sendRequest("/bulk-insert-file","POST",i,{isFile:!0});if(r)throw r;const a={};for(const o in s){const c=o,l=t==null?void 0:t[c].schema;a[c]=s[o].map(u=>le(l,u))}return a}async update(e,t,i){var l;let s;const r=await this.schema(),a=(l=r==null?void 0:r[e])==null?void 0:l.schema;if(typeof i=="function"){const u=await this.fetchById(e,t);if(!u)throw new Ue(t,e);s={},await i(ye(u,s,a))}else s=i;const{data:o,error:c}=await this.sendRequest("/update","POST",{collectionName:e,entityId:t,changes:s});if(c)throw c;return o}async delete(e,t){const{data:i,error:s}=await this.sendRequest("/delete","POST",{collectionName:e,entityId:t});if(s)throw s;return i}async deleteAll(e){const{data:t,error:i}=await this.sendRequest("/delete-all","POST",{collectionName:e});if(i)throw i;return t}query(e){return N(e)}}class ts{constructor(e){f(this,"formatter");this.formatter=e.formatter??(t=>[t])}log(e){const{level:t}=e,i=this.formatter(e);(t==="ERROR"||t==="FATAL")&&V(console.error)?console.error(...i):t==="WARN"&&V(console.warn)?console.warn(...i):t==="INFO"&&V(console.info)?console.info(...i):t==="DEBUG"&&V(console.debug)?console.debug(...i):console.log(...i)}startSpan(e,t,i){return console.log(`Starting span "${e}" in context="${t}"`,i),{name:e,context:t,attributes:i,startTime:Date.now()}}endSpan(e){if(!e)return;const t=Date.now()-e.startTime;console.log(`Ending span "${e.name}". Duration: ${t}ms`)}recordMetric(e,t,i){console.log(`Metric [${e}]: ${t}`,i||"")}}function V(n){return typeof n=="function"}function ns(){return new ts({formatter:n=>{const{level:e,message:t,timestamp:i,context:s,attributes:r}=n,a=s?[`%c${s}`,"color: #888"]:[];if(e==="DEBUG"&&s==="sync"){if(t==="sent")return["%c OUT ","background: #228; color: #51acff",r==null?void 0:r.type,r==null?void 0:r.payload];if(t==="received")return["%c IN ","background: #ccc; color: #333",r==null?void 0:r.type,r==null?void 0:r.payload]}return[...a,t,r||""]}})}class is{constructor(){f(this,"logs",[])}log(e){this.logs.push(e)}startSpan(e,t,i){return this.logs.push(`Starting span "${e}" in context="${t??""}" ${i?JSON.stringify(i):""}`),{name:e,context:t,attributes:i,startTime:Date.now()}}endSpan(e){if(!e)return;const t=Date.now()-e.startTime;this.logs.push(`Ending span "${e.name}". Duration: ${t}ms`)}recordMetric(e,t,i){this.logs.push(`Metric [${e}]: ${t} ${i?JSON.stringify(i):""}`)}}function ss(n,e){if(!n&&!e)return 0;if(!n)return-1;if(!e)return 1;let t=n[0],i=e[0];return t instanceof Date&&(t=t.getTime()),i instanceof Date&&(i=i.getTime()),rn(t,i)}const rs=1,w="triplit";class ne{constructor(e,t={useCache:!0}){f(this,"db");f(this,"cache");f(this,"options");this.options=t,t.useCache&&(this.cache=new de),this.db=typeof e=="string"?new Promise((i,s)=>{const r=indexedDB.open(e,rs);r.onupgradeneeded=a=>{const o=a.target.result;this.setupSchema(o)},r.onsuccess=async a=>{const o=a.target.result;i(await this.populateCache(o))},r.onerror=a=>{console.error(`Error opening database: ${a.target.error}`),s(a.target.error)}}):e.then(this.populateCache)}async populateCache(e){const i=e.transaction(w,"readonly").objectStore(w),s=await new Promise((a,o)=>{const c=i.getAllKeys();c.onerror=()=>o(c.error),c.onsuccess=()=>a(c.result)}),r=await new Promise((a,o)=>{const c=i.getAll();c.onerror=()=>o(c.error),c.onsuccess=()=>a(c.result)});if(s.length!==r.length)throw new Error("IndexedDB keys and values length mismatch");for(let a=0;a<s.length;a++){const o=s[a],c=r[a];this.cache&&this.cache.data.set(o,c)}return e}setupSchema(e){e.objectStoreNames.contains(w)||e.createObjectStore(w)}async get(e,t){const i=await this.db;if(this.cache)return this.cache.get(e,t);const s=t?[...t,...e]:e;return new Promise((r,a)=>{const l=i.transaction(w,"readonly",{durability:"relaxed"}).objectStore(w).get(s);l.onsuccess=()=>r(l.result),l.onerror=()=>a(l.error)})}async set(e,t,i){const s=await this.db,r=i?[...i,...e]:e;return new Promise((a,o)=>{const u=s.transaction(w,"readwrite",{durability:"relaxed"}).objectStore(w).put(t,r);u.onsuccess=async()=>{this.cache&&await this.cache.set(e,t,i),a()},u.onerror=()=>o(u.error)})}async delete(e,t){const i=await this.db,s=t?[...t,...e]:e;return new Promise((r,a)=>{const l=i.transaction(w,"readwrite",{durability:"relaxed"}).objectStore(w).delete(s);l.onsuccess=async()=>{this.cache&&await this.cache.delete(e,t),r()},l.onerror=()=>a(l.error)})}async*scan(e,t){const i=await this.db;if(this.cache){yield*this.cache.scan(e,t);return}const s=t?[...t,...e.prefix]:e.prefix,r=[...s,"￿"],o=i.transaction(w,"readonly",{durability:"relaxed"}).objectStore(w),c=this.options.batchSize??1e3;let l=s,u=!0;for(;!(Re(l,r)>=0);){const d=IDBKeyRange.bound(l,r,u,!0),h=await Me(o,d,c);if(!h.length)break;const y=await Le(o,d,c);if(!y.length)break;for(let b=0;b<h.length;b++){const T=((t==null?void 0:t.length)??0)+e.prefix.length,P=T>0?h[b].slice(T):h[b];if(P.length===0)break;yield[P,y[b]]}if(y.length<c)break;l=h.at(-1)}}async*scanValues(e,t){if(await this.db,this.cache){yield*this.cache.scanValues(e,t);return}const i=await this.db,s=t?[...t,...e.prefix]:e.prefix,r=[...s,"￿"],o=i.transaction(w,"readonly",{durability:"relaxed"}).objectStore(w),c=this.options.batchSize??1e3;let l=s,u=!0;for(;!(Re(l,r)>=0);){const d=IDBKeyRange.bound(l,r,u,!0),h=await Le(o,d,c);if(!h.length)break;for(const p of h)yield p;if(h.length<c)break;const g=await as(o,d,c);if(!g)break;l=g,u=!1}}async clear(e){const s=(await this.db).transaction(w,"readwrite",{durability:"relaxed"}).objectStore(w);if(e!=null&&e.length){const r=e,a=[...r,"￿"],o=IDBKeyRange.bound(r,a,!1,!0);return new Promise((c,l)=>{const u=s.delete(o);u.onsuccess=async()=>{this.cache&&await this.cache.clear(e),c()},u.onerror=()=>l(u.error)})}else{const r=s.clear();return new Promise((a,o)=>{r.onsuccess=async()=>{this.cache&&await this.cache.clear(e),a()},r.onerror=()=>o(r.error)})}}scope(e){return new an(this,e)}transact(){return new on(this)}async count(e,t){const i=await this.db;if(this.cache)return this.cache.count(e,t);const s=t?[...t,...e.prefix]:e.prefix,r=[...s,"￿"],a=IDBKeyRange.bound(s,r,!1,!0);return new Promise((o,c)=>{const d=i.transaction(w,"readonly",{durability:"relaxed"}).objectStore(w).count(a);d.onsuccess=()=>o(d.result),d.onerror=()=>c(d.error)})}async applyEdits(e,t){const i=await this.db;await new Promise(async(s,r)=>{const o=i.transaction(w,"readwrite",{durability:"relaxed"}).objectStore(w);let c=null;const l=[],u=[];for await(const d of t)c=o.delete(d),l.push(d);for await(const[d,h]of e)c=o.put(h,d),u.push([d,h]);c?(c.onsuccess=async()=>{this.cache&&await this.cache.applyEdits(u,l),s()},c.onerror=()=>r(c.error)):(this.cache&&await this.cache.applyEdits(u,l),s())})}async getBatchKeys(e,t){const r=(await this.db).transaction(w,"readonly",{durability:"relaxed"}).objectStore(w);return Me(r,e,t)}}function as(n,e,t=0){return new Promise((i,s)=>{const r=n.openKeyCursor(e,"next");let a=!1;r.onsuccess=o=>{const c=o.target,l=c==null?void 0:c.result;if(!l){i(void 0);return}if(!a&&t>1){a=!0,l.advance(t);return}i(l.key)},r.onerror=o=>{const c=o.target;s(c.error)}})}function Me(n,e,t){return new Promise((i,s)=>{const r=n.getAllKeys(e,t);r.onerror=()=>s(r.error),r.onsuccess=()=>i(r.result)})}function Le(n,e,t){return new Promise((i,s)=>{const r=n.getAll(e,t);r.onerror=()=>s(r.error),r.onsuccess=()=>i(r.result)})}function os(n){return typeof n=="string"||"type"in n}function cs(n){return typeof n=="string"&&n==="memory"||typeof n=="object"&&n.type==="memory"}function ls(n){return typeof n=="string"&&n==="indexeddb"||typeof n=="object"&&n.type==="indexeddb"}function us(n){if(!os(n))return n;if(cs(n))return new de;if(ls(n)){if(typeof indexedDB>"u")throw new cn;return typeof n=="object"?n.options?new ne(n.name??"triplit",n.options):new ne(n.name??"triplit"):new ne("triplit")}throw new S("Failed to parse storage input")}const ds="memory",ut=!0,fs={policy:"local-first",skipRules:ut};class hs{constructor(e={}){f(this,"awaitReady",null);f(this,"db");f(this,"syncEngine");f(this,"tokenRefreshTimer",null);f(this,"_token");f(this,"claimsPath");f(this,"_serverUrl");f(this,"skipRules",ut);f(this,"statusSubs",new Set);f(this,"syncSchema");f(this,"http");f(this,"defaultFetchOptions");f(this,"logger");f(this,"connectOnInitialization");f(this,"connectionOptionsChangeHandlers",[]);this.connectOnInitialization=e.autoConnect??!0;const t=e.schema?{collections:e.schema,roles:e.roles}:void 0,i=us((e==null?void 0:e.storage)??ds);this.syncSchema=e.syncSchema??!1,this.awaitReady=Vi({schema:t,variables:e.variables,entityStore:new Gi(i),kv:i,clientId:Math.random().toString(36).substring(7)}).then(r=>{const a=this.token?L(this.token,this.claimsPath):void 0;return this.db=a?r.withSessionVars(a):r,this.onConnectionOptionsChange(o=>{if("token"in o){const c=o.token?L(o.token,this.claimsPath):{};this.db=c?this.db.withSessionVars(c):this.db}}),this.db.onCommit(ys(async o=>{await this.db.updateQueryViews(),this.db.broadcastToQuerySubscribers(),this.syncEngine.connectionStatus==="OPEN"&&await this.syncEngine.syncWrites()},20)),this.db.onSchemaChange(o=>{o.successful&&this.http.updateOptions({schema:o.newSchema.collections})}),this.syncSchema&&this.subscribeBackground(this.db.query("_metadata").Id("_schema"),{onError:()=>{this.logger.warn("Schema sync disconnected")}}),Promise.resolve().then(()=>{this.awaitReady=null})}),this.logger=e.logger??new ln([ns()]),e.logLevel&&this.logger.setLogLevel(e.logLevel),e.logLevel==="debug"&&this.logger.registerHandler(new is),this.claimsPath=e.claimsPath,this.defaultFetchOptions={fetch:fs,...e.defaultQueryOptions},Qe(e.serverUrl),this._serverUrl=e.serverUrl,this.http=new es({serverUrl:this._serverUrl,token:this._token,schemaFactory:async()=>{var r;return(r=await this.getSchema())==null?void 0:r.collections}}),this.onConnectionOptionsChange(r=>{this.http.updateOptions(r)});const s=e.pingInterval||45;this.syncEngine=new Zi(this,{transport:e.transport,logger:this.logger.context("sync"),pingInterval:s}),e.onSessionError&&this.onSessionError(e.onSessionError),this.startSession(e.token,!1,e.refreshOptions).then(async()=>{if(this.connectOnInitialization){const r=await this.syncEngine.getConnectionParams();this.syncEngine.createConnection(r)}})}async getSchema(){return this.awaitReady&&await this.awaitReady,this.db.getSchema()}async transact(e,t={}){this.awaitReady&&await this.awaitReady,this.logger.debug("transact START");const i=await this.db.transact(e,{...t,skipRules:this.skipRules});return this.logger.debug("transact END",{txOutput:i}),i}query(e){return N(e)}async fetch(e,t){this.awaitReady&&await this.awaitReady,e=ie(e);const i={...this.defaultFetchOptions.fetch,...t??{}};if(i.policy==="local-only")return this.fetchLocal(e,i);if(i.policy==="local-first"){if(!(await this.syncEngine.isFirstTimeFetchingQuery(e)&&this.probablyIntendsToConnect))return await this.fetchLocal(e,i);try{await this.syncEngine.syncQuery(e)}catch(r){this.warnError(r)}return this.fetchLocal(e,i)}if(i.policy==="remote-first"){if(this.probablyIntendsToConnect)try{await this.syncEngine.syncQuery(e)}catch(s){this.warnError(s)}return this.fetchLocal(e,i)}if(i.policy==="remote-only")return this.http.fetch(e);if(i.policy==="local-and-remote"){const s=i.timeout??0;return await Promise.race([this.syncEngine.syncQuery(e),new Promise(r=>setTimeout(r,s))]).catch(this.warnError),this.fetchLocal(e,i)}throw new un(i.policy)}async fetchLocal(e,t){this.logger.debug("fetchLocal START",e);const i=await this.db.fetch(e,{skipRules:this.skipRules,...t??{}});return this.logger.debug("fetchLocal END",i),i}async fetchById(e,t,i){this.logger.debug("fetchById START",{collectionName:e,id:t,options:i});const s=this.query(e).Id(t),r=await this.fetchOne(s,i);return this.logger.debug("fetchById END",{collectionName:e,id:t,options:i,result:r}),r}async clear(e={full:!1}){this.awaitReady&&await this.awaitReady,await this.db.clear(e);for(const t of this.statusSubs)t.unsub(),t.unsub=this._subscribeWithStatus(t.query,t.callback,t.options)}async reset(e={}){await this.clear(e)}async fetchOne(e,t){e=ie(e),e={...e,limit:1};const s=[...(await this.fetch(e,t)).values()][0];return s||null}async insert(e,t){this.awaitReady&&await this.awaitReady,this.logger.debug("insert START",{collectionName:e,object:t});const i=await this.db.insert(e,t,{skipRules:this.skipRules});return this.logger.debug("insert END",{txOutput:i}),i}async update(e,t,i){this.awaitReady&&await this.awaitReady,this.logger.debug("update START",{collectionName:e,entityId:t});const s=await this.db.update(e,t,i,{skipRules:this.skipRules});return this.logger.debug("update END",{txOutput:s}),s}async delete(e,t){this.awaitReady&&await this.awaitReady,this.logger.debug("delete START",{collectionName:e,entityId:t});const i=await this.db.delete(e,t,{skipRules:this.skipRules});return this.logger.debug("delete END",{txOutput:i}),i}async entityIsInCache(e,t){return!!this.db.entityStore.doubleBuffer.getChangesForEntity(this.db.kv,e,t)}subscribe(e,t,i,s){let r=!1;const a=(async()=>{this.awaitReady&&await this.awaitReady;const o={localOnly:!1,...s??{}};e=ie(e),this.logger.debug("subscribe start",e);const c=t,l=i;t=async h=>{let y=h;r||(s!=null&&s.syncStatus&&s.syncStatus!=="all"&&(y=await this.filterResultsWithSyncStatus(h,e.collectionName,s.syncStatus)),c(y))},i=l?h=>{r||l(h)}:void 0;const u=this.db.subscribe(e,t,i,{skipRules:this.skipRules,...o});await this.db.updateQueryViews(),this.db.broadcastToQuerySubscribers();let d=Promise.resolve(()=>{});return o.localOnly||(d=this.syncEngine.subscribe(e,{onQueryFulfilled:o.onRemoteFulfilled,onQueryError:i,onQuerySyncStateChange:o.onQuerySyncStateChange})),()=>{r=!0,u(),d.then(h=>h())}})();return()=>{a.then(o=>o())}}get probablyIntendsToConnect(){return this.connectionStatus==="OPEN"||this.connectionStatus==="CONNECTING"||!!this.connectOnInitialization&&!!this.token&&!!this.serverUrl&&this.connectionStatus!=="CLOSED"&&this.connectionStatus!=="CLOSING"}subscribeWithStatus(e,t,i){const s={query:e,callback:t,options:i,unsub:this._subscribeWithStatus(e,t,i)};return this.statusSubs.add(s),()=>{s.unsub(),this.statusSubs.delete(s)}}_subscribeWithStatus(e,t,i){let s,r=this.probablyIntendsToConnect&&!(i!=null&&i.localOnly),a=!0,o=!1,c,l=!0;const u=()=>a||l&&r;function d(){t({results:s,error:c,fetching:u(),fetchingLocal:a,fetchingRemote:o})}d();const h=this.onConnectionStatusChange(g=>{if(g==="CLOSING"||g==="CLOSED"){let p=!1;o&&(o=!1,p=!0),r&&(r=!1,p=!0),p&&d();return}},!0);this.isFirstTimeFetchingQuery(e).then(g=>{if(l!==g){const p=u();l=g,u()!==p&&d()}});const y=this.subscribe(e,g=>{s=g,a=!1,c=void 0,o&&(o=!this.syncEngine.hasServerRespondedForQuery(e),r=o),d()},g=>{c=g,a=!1,d()},{...i??{},onQuerySyncStateChange:g=>{if(g==="FULFILLED"||g==="ERROR"){if(!o)return;o=!1,r=!1,d()}g==="IN_FLIGHT"&&!o&&(o=!0,d())}});return()=>{y(),h()}}async filterResultsWithSyncStatus(e,t,i){const s=await this.db.entityStore.doubleBuffer.getChangesForCollection(this.db.kv,t);return s?i==="pending"?e.filter(r=>s.sets.has(r.id)):e.filter(r=>!s.sets.has(r.id)):i==="pending"?[]:e}subscribeBackground(e,t={}){const i=(async()=>(this.awaitReady&&await this.awaitReady,this.syncEngine.subscribe(e,{onQueryFulfilled:t.onFulfilled,onQueryError:t.onError})))();return()=>{i.then(s=>s())}}subscribeWithPagination(e,t,i,s){e.order&&e.order.length>0&&e.order.at(-1)[0]!=="id"&&(e.order=[...e.order,["id","ASC"]]);const r={},a=e.limit;let o=d=>{t(d,{hasNextPage:!1,hasPreviousPage:!1})};r.nextPage=()=>{this.logger.warn("There is no limit set on the query, so nextPage() is a no-op")},r.prevPage=()=>{this.logger.warn("There is no limit set on the query, so prevPage() is a no-op")};let c,l,u="forward";return e.limit&&(e={...e},e.limit=a+1+(e.after?1:0),o=d=>{var X,ge,pe;if(!((ge=(X=e.order)==null?void 0:X[0])==null?void 0:ge[0]))throw new S("No cursor attribute found in query order");const y=d.at(0),g=!!e.after&&!!y&&ss(e.after[0],e.order.map(D=>A.Get(y,D[0].split("."))))>-1,p=d.length>=e.limit,b=u==="reversed"?p:g,T=u==="forward"?p:g;d=d.slice(g?1:0,p?-1:void 0);const P=d.at(0),U=d.at(a-1);c=P?e.order.map(D=>A.Get(P,D[0].split("."))):void 0,l=U?e.order.map(D=>A.Get(U,D[0].split("."))):void 0,u==="reversed"&&(d=d.reverse()),!b&&e.after?((pe=r.unsubscribe)==null||pe.call(r),e={...e},e.after=void 0,e.limit=a+1,u==="reversed"&&(e.order=se(e.order)),u="forward",r.unsubscribe=this.subscribe(e,o,i,s)):t(d,{hasNextPage:T,hasPreviousPage:b})},r.nextPage=()=>{var d;(d=r.unsubscribe)==null||d.call(r),e={...e},u==="reversed"?(e.order=se(e.order),e.after=c?[c,!0]:void 0):(e.after||(e.limit=e.limit+1),e.after=l?[l,!0]:void 0),u="forward",r.unsubscribe=this.subscribe(e,o,i,s)},r.prevPage=()=>{var d;(d=r.unsubscribe)==null||d.call(r),e={...e},u==="forward"?(e.order=se(e.order),e.after=c?[c,!0]:void 0):e.after=l?[l,!0]:void 0,u="reversed",r.unsubscribe=this.subscribe(e,o,i,s)}),r.unsubscribe=this.subscribe(e,o,i,s),r}subscribeWithExpand(e,t,i,s){var o;const r={};let a=c=>{t(c,{hasMore:!1})};if(r.loadMore=()=>{this.logger.warn("There is no limit set on the query, so loadMore is a no-op")},e.limit){(!e.order||((o=e.order.at(-1))==null?void 0:o[0])!=="id")&&(e.order=[...e.order??[],["id","ASC"]]);const c=e.limit;e={...e},e.limit=e.limit+1,a=l=>{const u=l.length>=e.limit;l=Array.from(l),u&&(l=l.slice(0,-1)),t(l,{hasMore:u})},r.loadMore=l=>{var u;(u=r.unsubscribe)==null||u.call(r),e={...e},e.limit=(e.limit??1)+(l??c),r.unsubscribe=this.subscribe(e,a,i,s)}}return r.unsubscribe=this.subscribe(e,a,i,s),r}updateConnectionOptions(e){const{token:t,serverUrl:i,tokenRefresh:s}=e,r=e.hasOwnProperty("token")&&t!==this.token,a=e.hasOwnProperty("serverUrl")&&i!==this.serverUrl;let o={};if(r&&(o={...o,token:t,tokenRefresh:s}),a&&(Qe(i),o={...o,serverUrl:i}),r||a){r&&(this._token=t),a&&(this._serverUrl=i);for(const c of this.connectionOptionsChangeHandlers)c(o)}}async startSession(e,t=!0,i){const s=L(e);if(s&&De(s)){if(!(i!=null&&i.refreshHandler))throw new Ie;const c=await i.refreshHandler();if(!c){this.logger.warn("An expired token was passed to startSession, and the refreshHandler was unable to provide a new token. Session will not be started");return}e=c}if(e===this.token||(this.token&&await this.endSession(),this.updateToken(e),t&&await this.connect(),!i||!this.token))return;const{interval:r,refreshHandler:a}=i,o=c=>{const l=L(c);if(!l||!l.exp&&!r)return;let u=r??l.exp*1e3-Date.now()-1e3;u<1e3&&(this.logger.warn(`The minimum allowed refresh interval is 1000ms, the ${r?"provided interval":"interval determined from the provided token"} was ${Math.round(u)}ms.`),u=1e3),this.tokenRefreshTimer=setTimeout(async()=>{const d=await a();if(!d){this.logger.warn("The token refresh handler did not return a new token, ending the session."),await this.endSession();return}await this.updateSessionToken(d),o(d)},u)};return o(this.token),()=>{this.resetTokenRefreshHandler()}}async endSession(){this.resetTokenRefreshHandler(),this.disconnect(),this.updateToken(void 0),this.syncEngine.resetQueryState()}async updateSessionToken(e){var r;if(this.awaitReady&&await this.awaitReady,!this.token)throw new dn;const t=L(e);if(!t)throw new fn(t);if(De(t))throw new Ie;const i=nt(this.db.schema,it(t));if(!wi((r=this.db.session)==null?void 0:r.roles,i))throw new hn;if(this.updateToken(e,!0),!this.syncEngine.updateTokenForSession(e)&&!await new Promise((o,c)=>setTimeout(()=>o(this.syncEngine.updateTokenForSession(e)),1e3)))throw new S("Failed to update the session token for the current session.")}resetTokenRefreshHandler(){this.tokenRefreshTimer&&(clearTimeout(this.tokenRefreshTimer),this.tokenRefreshTimer=null)}onSessionError(e){return this.syncEngine.onSessionError(e)}async updateGlobalVariables(e){this.awaitReady&&await this.awaitReady,this.db.updateGlobalVariables(e)}updateToken(e,t){this.updateConnectionOptions({token:e,tokenRefresh:t})}updateServerUrl(e){this.updateConnectionOptions({serverUrl:e})}onConnectionStatusChange(...e){return this.syncEngine.onConnectionStatusChange(...e)}connect(){return this.syncEngine.connect()}disconnect(){return this.syncEngine.disconnect()}get token(){return this._token}get serverUrl(){return this._serverUrl}get vars(){return{...this.db.systemVars,$token:this.db.systemVars.$session}}onSyncMessageReceived(...e){return this.syncEngine.onSyncMessageReceived(...e)}onSyncMessageSent(...e){return this.syncEngine.onSyncMessageSent(...e)}onEntitySyncSuccess(...e){return this.syncEngine.onEntitySyncSuccess(...e)}onEntitySyncError(...e){return this.syncEngine.onEntitySyncError(...e)}onFailureToSyncWrites(...e){return this.syncEngine.onFailureToSyncWrites(...e)}syncWrites(...e){return this.syncEngine.syncWrites(...e)}get connectionStatus(){return this.syncEngine.connectionStatus}isFirstTimeFetchingQuery(...e){return this.syncEngine.isFirstTimeFetchingQuery(...e)}async clearPendingChangesForEntity(...e){return this.syncEngine.clearPendingChangesForEntity(...e)}async clearPendingChangesAll(...e){return this.syncEngine.clearPendingChangesAll(...e)}onConnectionOptionsChange(e){return this.connectionOptionsChangeHandlers.push(e),()=>{this.connectionOptionsChangeHandlers=this.connectionOptionsChangeHandlers.filter(t=>t!==e)}}warnError(e){e instanceof S?this.logger.warn(e.toJSON()):this.logger.warn(e)}}function ie(n){return{traceId:Math.random().toString().slice(2),...n}}function se(n){if(n)return n.map(e=>[e[0],e[1]==="ASC"?"DESC":"ASC"])}function ys(n,e,t){let i,s=null;return function(){const r=arguments;i?s=r:(s=r,i=!0,setTimeout(()=>{s&&(n(s),s=null),i=!1},e))}}function Qe(n){if(n&&!n.startsWith("http://")&&!n.startsWith("https://"))throw new S("Invalid serverUrl provided")}const gs=yn;function Is(n,e){yt(e,!1);const t=gn.find(l=>l.id===Cn.params.demoId);t||(console.error("This demo does not exist."),Sn("/demos"));const i=new hs({schema:gs,roles:pn,autoConnect:!1});async function s(){return{account:Pe.account,profile:Pe.profile}}const r=mn(i,s,!0);gt(bn,r),wn(),Et(async()=>{const l=t.seed();await i.transact(async u=>{for(const[d,h]of Object.entries(l))for(const y of h)await u.insert(d,y)})}),ht();var a=St();bt(l=>{wt.title="Demo - Verdagraph"});var o=pt(a);{var c=l=>{t.component(l,{})};vt(o,l=>{t&&l(c)})}Ct(n,a),mt()}export{Is as component};
