import{t,G as w,n as u,A as d}from"./Bn6OaK2A.js";import{g as h,r as p,m as f}from"./4j4wuK16.js";const I=(e,r,i)=>{switch(i){case"ADMIN":return!!e.adminIds.has(r);case"EDITOR":return!!(e.adminIds.has(r)||e.editorIds.has(r));case"VIEWER":return!!(e.adminIds.has(r)||e.editorIds.has(r)||e.viewerIds.has(r));default:return!1}},b=t.query("profiles").Where("id","in","$query.profileIds"),g=t.query("profiles").Where("username","in","$query.usernames");async function v(e,r){const i=await u(),s=await t.fetchOne(h.Vars({id:e}));if(s==null)throw new d("Garden key does not exist.",{nonFormErrors:["Garden key does not exist."]});const o=p(r);if(!I(s,i.profile.id,o))throw new d(`Requires ${o} access.`,{nonFormErrors:[`This action requires the ${o} role.`]});return{client:i,garden:s}}async function l(e,r){if(!e)return new Set;const i=await t.fetch(g.Vars({usernames:e}));return new Set(i.filter(s=>r===void 0).map(s=>s.id))}const D={schema:w,mutation:async function(e){const r=await u();if(await t.fetchOne(h.Vars({id:e.id})))throw new d("Garden ID already exists.",{fieldErrors:{id:["Key already exists."]}});const s=await l(e.adminInvites),o=await l(e.editorInvites),m=await l(e.viewerInvites);s.add(r.profile.id);let n=null;if(await t.transact(async a=>{n=await a.insert("gardens",{id:e.id,name:e.name,visibility:e.visibility,description:e.description,creatorId:r.profile.id,adminIds:s,editorIds:o,viewerIds:m}),await a.insert("gardenMemberships",{gardenId:n.id,userId:r.profile.id,role:"ADMIN",inviterId:null,status:"ACCEPTED"});for(const c in s)c!==r.profile.id&&await a.insert("gardenMemberships",{gardenId:n.id,userId:c,role:"ADMIN",inviterId:r.profile.id,status:"CREATED"});for(const c in o)await a.insert("gardenMemberships",{gardenId:n.id,userId:c,role:"EDITOR",inviterId:r.profile.id,status:"CREATED"});for(const c in m)await a.insert("gardenMemberships",{gardenId:n.id,userId:c,role:"VIEWER",inviterId:r.profile.id,status:"CREATED"});await a.insert("workspaces",{gardenId:n.id,name:"Default",slug:"default"}),await a.insert("environments",{gardenId:n.id,name:"Garden",parentType:"GARDEN",attributes:{}})}),n==null)throw new d("Failed to create garden.");return n}},A={mutation:async function(e){const r=await u(),i=await t.fetchOne(f.Vars({gardenId:e.gardenId,userId:r.profile.id}));if(!i)throw new d("Membership does not exist in the collection.",{nonFormErrors:["The invite to this garden does not exist."]});if(i.status==="ACCEPTED")throw new d("Membership was already accepted.",{nonFormErrors:["The invite to this garden is already accepted."]});await t.update("gardenMemberships",i.id,async s=>{s.status="ACCEPTED",s.acceptedAt=new Date})}},M={mutation:async function(e){const r=await u(),i=await t.fetchOne(f.Vars({gardenId:e.gardenId,userId:r.profile.id}));if(!i)throw new d("Membership does not exist in the collection.",{nonFormErrors:["The membership in this garden does not exist."]});await t.delete("gardenMemberships",i.id)}};export{M as a,g as b,D as c,A as g,v as r,b as u};
