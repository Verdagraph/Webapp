import{P as u,t as r,A as l,W as h}from"./Dk6orzBZ.js";import{r as g}from"./Cks1JJCX.js";function f(o,e){return o.getFullYear()===e.getFullYear()&&o.getMonth()===e.getMonth()&&o.getDate()===e.getDate()}function x(o,e){if(o.length===0)return null;const i=e.getTime(),n=[...o].sort((s,t)=>s.date.getTime()-t.date.getTime());if(i<n[0].date.getTime())return null;if(i>=n[n.length-1].date.getTime())return n[n.length-1];for(let s=0;s<n.length-1;s++){const t=n[s].date.getTime(),a=n[s+1].date.getTime();if(i>=t&&i<a)return n[s]}return null}function w(o,e){return[...o].find(i=>f(i.date,e))||null}function F(o){switch(o.type){case"RECTANGLE":return o.rectangleWidth/2*o.scaleFactor;case"POLYGON":return o.polygonRadius*o.scaleFactor;case"ELLIPSE":return o.ellipseWidth/2*o.scaleFactor;case"LINES":return Math.max(...o.linesCoordinates.map(e=>e.y))*o.scaleFactor}}function y(o){return o=o.replace(/^\s+|\s+$/g,""),o=o.toLowerCase(),o=o.replace(/[^a-z0-9 -]/g,"").replace(/\s+/g,"-").replace(/-+/g,"-"),o}async function I(o,e,i){const n=[];if(e.linesCoordinates&&e.type==="LINES")for(const t of e.linesCoordinates){const a=await i.insert("coordinates",{gardenId:o,x:t.x,y:t.y});n.push(a.id)}const s={gardenId:o,type:e.type,date:e.date,scaleFactor:e.scaleFactor,rotation:e.rotation,rectangleLength:e.rectangleLength,rectangleWidth:e.rectangleWidth,polygonNumSides:e.polygonNumSides,polygonRadius:e.polygonRadius,ellipseLength:e.ellipseLength,ellipseWidth:e.ellipseWidth,linesCoordinateIds:new Set(n),linesClosed:e.linesClosed};return await i.insert("geometries",s)}async function L(o,e){const i=await r.fetchOne(r.query("geometries").Id(o));if(!i)throw new l("Geometry does not exist.",{nonFormErrors:["Failed to update object geometry."]});if(e.delete){await r.delete("geometries",o);return}await r.transact(async n=>{let s=[...i.linesCoordinateIds];if(e.linesCoordinates){const t=e.linesCoordinates.length,a=Math.min(s.length,t);for(let c=0;c<a;c++){const d=s[c];await n.update("coordinates",d,p=>{e.linesCoordinates&&(p.x=e.linesCoordinates[c].x,p.y=e.linesCoordinates[c].y)})}if(s.length>t){const c=s.slice(t);for(const d of c)await n.delete("coordinates",d);s=s.slice(0,t)}if(t>s.length){const c=e.linesCoordinates.slice(s.length);for(const d of c){const p=await n.insert("coordinates",{gardenId:i.gardenId,x:d.x,y:d.y});s.push(p.id)}}}await n.update("geometries",i.id,t=>{e.type&&(t.type=e.type),e.date&&(t.date=e.date),e.scaleFactor&&(t.scaleFactor=e.scaleFactor),e.rotation&&(t.rotation=e.rotation),e.rectangleLength&&(t.rectangleLength=e.rectangleLength),e.rectangleWidth&&(t.rectangleWidth=e.rectangleWidth),e.polygonNumSides&&(t.polygonNumSides=e.polygonNumSides),e.polygonRadius&&(t.polygonRadius=e.polygonRadius),e.ellipseLength&&(t.ellipseLength=e.ellipseLength),e.ellipseWidth&&(t.ellipseWidth=e.ellipseWidth),e.linesCoordinates&&(t.linesCoordinateIds=new Set(s)),e.linesClosed&&(t.linesClosed=e.linesClosed)})})}async function m(o,e){const i=await e.insert("locations",{gardenId:o.gardenId,workspaceId:o.workspaceId,x:o.coordinate.x,y:o.coordinate.y,date:o.date});return await e.insert("locationHistories",{gardenId:o.gardenId,locationIds:new Set([i.id]),workspaceIds:new Set([o.workspaceId])})}async function W(o,e){if(!await r.fetchOne(r.query("locations").Id(o)))throw new l("Location does not exist.",{nonFormErrors:["Failed to update object location."]});if(e.delete){await r.delete("locations",o);return}await r.update("locations",o,n=>{e.coordinate&&(n.x=e.coordinate.x,n.y=e.coordinate.y),e.date&&(n.date=e.date),e.workspaceId&&(n.workspaceId=e.workspaceId)})}async function S(o){const e=await r.fetchOne(r.query("locationHistories").Id(o.id).Include("locations"));if(!e)throw new l("Location history does not exist.",{nonFormErrors:["Failed to update object location."]});const i=w(e.locations,o.date);i?await r.update("locations",i.id,n=>{n.x=o.coordinate.x,n.y=o.coordinate.y}):await r.transact(async n=>{const s=await n.insert("locations",{gardenId:e.gardenId,workspaceId:o.workspaceId,x:o.coordinate.x,y:o.coordinate.y,date:o.date});await r.update("locationHistories",e.id,t=>{t.locationIds.add(s.id),t.workspaceIds.has(o.workspaceId)||t.workspaceIds.add(o.workspaceId)})})}async function E(o,e){const i=await r.fetchOne(r.query("locationHistories").Id(o).Include("locations"));if(!i)throw new l("Location history does not exist.",{nonFormErrors:["Failed to update object location."]});const n=w(i.locations,e)||i.locations[i.locations.length-1]||{x:0,y:0};await r.transact(async s=>{const t=await s.insert("locations",{gardenId:i.gardenId,workspaceId:n.workspaceId,x:n.x,y:n.y,date:e});await s.update("locationHistories",o,a=>{a.locationIds.add(t.id)})})}const T={schema:h,mutation:async function(o){await g(o.gardenId,"WorkspaceCreate");const e=y(o.name);if(await r.fetchOne(r.query("workspaces").Where([["gardenId","=",o.gardenId],["slug","=",e]])))throw new l("Workspace slug already exists.",{fieldErrors:{name:["This workspace name already exists in this garden."]}});return await r.insert("workspaces",{gardenId:o.gardenId,name:o.name,slug:e,description:o.description})}},H={schema:u,mutation:async o=>{const{garden:e}=await g(o.gardenId,"PlantingAreaCreate");if(await r.fetchOne(r.query("workspaces").Id(o.workspaceId))==null)throw new l(`Failed to retrieve workspace ${o.workspaceId}`,{nonFormErrors:["Failed to retrieve workspace."]});await r.transact(async n=>{const s=await I(o.gardenId,o.geometry,n),t=await m(o.location,n);await n.insert("plantingAreas",{gardenId:e.id,name:o.name,description:o.description||"",geometryId:s.id,locationHistoryId:t.id,depth:o.depth})})}},A={mutation:async function(o,e){if(await r.fetchOne(r.query("plantingAreas").Id(o))==null)throw new l(`Failed to retrieve planting area ${o}`,{nonFormErrors:["Failed to retrieve planting area."]});await r.update("plantingAreas",o,n=>{e.name&&(n.name=e.name),e.description&&(n.description=e.description),e.depth&&(n.depth=e.depth)})}};export{L as a,E as b,W as c,H as d,F as g,x as h,S as l,A as p,T as w};
